[
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ]\nPrimary Keys = [ PERSON.ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL FROM PERSON A, PERSON B WHERE A.EMAIL = B.EMAIL AND A.ID != B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ORDERS.CUSTOMERID = CUSTOMERS.ID ]\nPrimary Keys = [ CUSTOMERS.ID, ORDERS.ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C LEFT JOIN ORDERS AS O ON C.ID = O.CUSTOMERID WHERE O.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN (SELECT PLAYER_ID, MIN(EVENT_DATE) FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(CASE WHEN A2.PLAYER_ID IS NOT NULL THEN 1 ELSE 0 END)/COUNT(DISTINCT A1.PLAYER_ID),2) AS FRACTION FROM (SELECT MIN(EVENT_DATE) AS EVENT_DATE,PLAYER_ID FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID=A2.PLAYER_ID AND DATEDIFF(A2.EVENT_DATE, A1.EVENT_DATE)=1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(IF(T2.EVENT_DATE IS NOT NULL, 1,0)) / COUNT(DISTINCT(T1.PLAYER_ID)),2) FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND DATEDIFF(T2.EVENT_DATE, T1.EVENT_DATE) = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND((COUNT(DISTINCT C.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID)),2) AS FRACTION FROM ACTIVITY A LEFT JOIN CTE C ON A.PLAYER_ID = C.PLAYER_ID AND DATEDIFF(A.EVENT_DATE,C.FIRST_LOGIN) = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH FIRST_LOGIN AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN, MIN(EVENT_DATE) + 1 AS TARGET_DATE FROM ACTIVITY GROUP BY PLAYER_ID ), SECOND_LOGINS AS ( SELECT ACTIVITY.PLAYER_ID, ACTIVITY.EVENT_DATE, CASE WHEN FIRST_LOGIN.PLAYER_ID IS NULL THEN 0 ELSE 1 END AS TARGET_LOGIN FROM ACTIVITY LEFT JOIN FIRST_LOGIN ON ACTIVITY.PLAYER_ID = FIRST_LOGIN.PLAYER_ID AND ACTIVITY.EVENT_DATE = FIRST_LOGIN.TARGET_DATE ) SELECT ROUND(SUM(TARGET_LOGIN)/COUNT(DISTINCT PLAYER_ID),2) AS FRACTION FROM SECOND_LOGINS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH FIRST_DATE AS ( SELECT PLAYER_ID , MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ROUND(COUNT(A.PLAYER_ID) / (SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY),2) AS FRACTION FROM ACTIVITY A JOIN FIRST_DATE FD ON A.PLAYER_ID = FD.PLAYER_ID WHERE DATEDIFF(A.EVENT_DATE, FD.FIRST_DATE) = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ROUND(SUM(CASE WHEN DATEDIFF(A.EVENT_DATE, FIRST_DATE) = 1 THEN 1 ELSE 0 END) / COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM CTE JOIN ACTIVITY A ON CTE.PLAYER_ID = A.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID=B.EMPID WHERE B.BONUS<1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT T1.NAME, T2.BONUS FROM EMPLOYEE T1 LEFT JOIN BONUS T2 ON T1.EMPID = T2.EMPID WHERE BONUS IS NULL OR BONUS<1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E1.NAME,B1.BONUS FROM EMPLOYEE E1 LEFT JOIN BONUS B1 ON E1.EMPID= B1.EMPID WHERE B1.BONUS<1000 OR ISNULL(B1.BONUS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME ,BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID=B.EMPID WHERE IFNULL(BONUS,0)<1000 GROUP BY E.EMPID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE T1 LEFT JOIN BONUS T2 USING(EMPID) WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable TRIANGLE, Columns = [ *, X, Y, Z ]\n\nForeign Keys = [ ]\nPrimary Keys = [ TRIANGLE.X ]\n\n### SQL\n[SQL_1] SELECT X, Y, Z, IF(X+Y>Z AND X+Z>Y AND Y+Z>X, 'YES', 'NO') AS TRIANGLE FROM TRIANGLE;\n[SQL_2] SELECT X,Y,Z, IF(X+Y <= Z OR Z+Y <= X OR X+Z <= Y, 'NO','YES') AS TRIANGLE FROM TRIANGLE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FOLLOW, Columns = [ *, FOLLOWEE, FOLLOWER ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FOLLOW.FOLLOWEE ]\n\n### SQL\n[SQL_1] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWEE) AS NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY 1 ORDER BY 1;\n[SQL_2] SELECT F.FOLLOWER, COUNT(DISTINCT FF.FOLLOWER) AS NUM FROM FOLLOW F INNER JOIN FOLLOW FF ON F.FOLLOWER = FF.FOLLOWEE GROUP BY F.FOLLOWER;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FOLLOW, Columns = [ *, FOLLOWEE, FOLLOWER ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FOLLOW.FOLLOWEE ]\n\n### SQL\n[SQL_1] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWEE) AS NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY 1 ORDER BY 1;\n[SQL_2] SELECT FOLLOWEE AS FOLLOWER, COUNT(DISTINCT FOLLOWER) NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY FOLLOWEE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FOLLOW, Columns = [ *, FOLLOWEE, FOLLOWER ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FOLLOW.FOLLOWEE ]\n\n### SQL\n[SQL_1] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWEE) AS NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY 1 ORDER BY 1;\n[SQL_2] SELECT A.FOLLOWER, COUNT(DISTINCT B.FOLLOWER) AS NUM FROM FOLLOW A LEFT JOIN FOLLOW B ON A.FOLLOWER = B. FOLLOWEE WHERE B.FOLLOWER IS NOT NULL GROUP BY A.FOLLOWER;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FOLLOW, Columns = [ *, FOLLOWEE, FOLLOWER ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FOLLOW.FOLLOWEE ]\n\n### SQL\n[SQL_1] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWEE) AS NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY 1 ORDER BY 1;\n[SQL_2] WITH LEF AS ( SELECT DISTINCT FOLLOWER FROM FOLLOW WHERE FOLLOWER IN (SELECT DISTINCT FOLLOWEE FROM FOLLOW) ) , ANS AS ( SELECT A.FOLLOWER,B.FOLLOWER AS CC FROM LEF AS A INNER JOIN FOLLOW AS B ON A.FOLLOWER=B.FOLLOWEE) SELECT FOLLOWER,COUNT(DISTINCT CC) AS NUM FROM ANS GROUP BY FOLLOWER ORDER BY FOLLOWER;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FOLLOW, Columns = [ *, FOLLOWEE, FOLLOWER ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FOLLOW.FOLLOWEE ]\n\n### SQL\n[SQL_1] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWEE) AS NUM FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) GROUP BY 1 ORDER BY 1;\n[SQL_2] SELECT FOLLOWEE AS FOLLOWER, COUNT(FOLLOWER) AS NUM FROM FOLLOW WHERE FOLLOWEE IN ( SELECT FOLLOWEE AS USERS FROM FOLLOW WHERE FOLLOWEE IN (SELECT FOLLOWER FROM FOLLOW) UNION SELECT FOLLOWER AS USERS FROM FOLLOW WHERE FOLLOWER IN (SELECT FOLLOWEE FROM FOLLOW) ) GROUP BY FOLLOWEE ORDER BY FOLLOWEE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT CASE WHEN SUM(SINGLE_TAG) = NULL THEN NULL ELSE MAX(SINGLE_TAG) END AS NUM FROM (SELECT NUM, CASE WHEN COUNT(*) = 1 THEN NUM ELSE NULL END AS SINGLE_TAG FROM MYNUMBERS GROUP BY NUM) N;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM ( SELECT NUM FROM MYNUMBERS GROUP BY 1 HAVING COUNT(NUM) = 1) AS T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(A.NUM) AS NUM FROM( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*)=1 ORDER BY NUM DESC LIMIT 1)A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM, COUNT(*) AS CNT FROM MYNUMBERS GROUP BY NUM) T WHERE CNT = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTORDIRECTOR.TIMESTAMP ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID ACTOR_ID, DIRECTOR_ID AS DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*) >=3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID ]\nPrimary Keys = [ PROJECT.PROJECT_ID, EMPLOYEE.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID , ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID ]\nPrimary Keys = [ PROJECT.PROJECT_ID, EMPLOYEE.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(SUM(EXPERIENCE_YEARS)/COUNT(EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT INNER JOIN EMPLOYEE USING(EMPLOYEE_ID) GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID ]\nPrimary Keys = [ PROJECT.PROJECT_ID, EMPLOYEE.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND((AVG(E.EXPERIENCE_YEARS)), 2) AS AVERAGE_YEARS FROM PROJECT AS P JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT A.BUYER_ID FROM SALES A INNER JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID AND PRODUCT_NAME='S8'), CTE1 AS( SELECT A.BUYER_ID FROM SALES A INNER JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID AND PRODUCT_NAME='IPHONE') SELECT DISTINCT BUYER_ID FROM CTE A WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH DRAFT AS ( SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM DRAFT WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM DRAFT WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID) GROUP BY PRODUCT_ID HAVING MAX(SALE_DATE) <= '2019-03-31' AND MIN(SALE_DATE) >= '2019-01-01';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(S.SALE_DATE) >= '2019-1-1' AND MAX(S.SALE_DATE) <= '2019-3-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND'2019-03-31') AND PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND'2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID= P.PRODUCT_ID GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT SALES.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH F AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRSTDAY FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.EVENT_DATE AS INSTALL_DT, COUNT(DISTINCT F.PLAYER_ID) AS INSTALLS, IFNULL(ROUND(COUNT(DISTINCT S.PLAYER_ID) / COUNT(DISTINCT F.PLAYER_ID),2),0) AS DAY1_RETENTION FROM ACTIVITY A JOIN F ON A.EVENT_DATE = F.FIRSTDAY LEFT JOIN ACTIVITY S ON F.PLAYER_ID = S.PLAYER_ID AND S.EVENT_DATE = F.FIRSTDAY+1 GROUP BY A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.PLAYER_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(*) AS INSTALLS, ROUND(SUM(NEXT_DAY)/COUNT(*), 2) AS DAY1_RETENTION FROM (SELECT A.PLAYER_ID, A.EVENT_DATE AS INSTALL_DT, (A.PLAYER_ID, DATE_ADD(A.EVENT_DATE, INTERVAL 1 DAY)) IN (SELECT PLAYER_ID, EVENT_DATE FROM ACTIVITY) AS NEXT_DAY FROM ACTIVITY A INNER JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS T1 ON (A.PLAYER_ID, A.EVENT_DATE) = (T1.PLAYER_ID, T1.EVENT_DATE)) AS T GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SPENDING, Columns = [ *, USER_ID, SPEND_DATE, PLATFORM, AMOUNT ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SPENDING.USER_ID ]\n\n### SQL\n[SQL_1] SELECT P.SPEND_DATE,P.PLATFORM,IFNULL(SUM(AMOUNT), 0) TOTAL_AMOUNT,COUNT(USER_ID) TOTAL_USERS FROM (SELECT DISTINCT(SPEND_DATE), 'DESKTOP' PLATFORM FROM SPENDING UNION SELECT DISTINCT(SPEND_DATE), 'MOBILE' PLATFORM FROM SPENDING UNION SELECT DISTINCT(SPEND_DATE), 'BOTH' PLATFORM FROM SPENDING) P LEFT JOIN (SELECT SPEND_DATE, USER_ID, IF(MOBILE_AMOUNT > 0, IF(DESKTOP_AMOUNT > 0, 'BOTH', 'MOBILE'), 'DESKTOP') PLATFORM,(MOBILE_AMOUNT + DESKTOP_AMOUNT) AMOUNT FROM (SELECT SPEND_DATE, USER_ID, SUM(CASE PLATFORM WHEN 'MOBILE' THEN AMOUNT ELSE 0 END) MOBILE_AMOUNT, SUM(CASE PLATFORM WHEN 'DESKTOP' THEN AMOUNT ELSE 0 END) DESKTOP_AMOUNT FROM SPENDING GROUP BY SPEND_DATE, USER_ID) O) T ON P.PLATFORM=T.PLATFORM AND P.SPEND_DATE=T.SPEND_DATE GROUP BY SPEND_DATE, PLATFORM;\n[SQL_2] WITH TEMP AS (SELECT USER_ID, SPEND_DATE, SUM(CASE WHEN PLATFORM='MOBILE' THEN AMOUNT ELSE 0 END) AS MOBILE_AMT, SUM(CASE WHEN PLATFORM='DESKTOP' THEN AMOUNT ELSE 0 END) AS DESKTOP_AMT FROM SPENDING GROUP BY USER_ID, SPEND_DATE) (SELECT SPEND_DATE, 'MOBILE' AS PLATFORM, SUM(CASE WHEN MOBILE_AMT > 0 AND DESKTOP_AMT = 0 THEN MOBILE_AMT ELSE 0 END) AS TOTAL_AMOUNT, COUNT(CASE WHEN MOBILE_AMT > 0 AND DESKTOP_AMT = 0 THEN 1 END) AS TOTAL_USERS FROM TEMP GROUP BY SPEND_DATE) UNION ALL (SELECT SPEND_DATE, 'DESKTOP' AS PLATFORM, SUM(CASE WHEN MOBILE_AMT = 0 AND DESKTOP_AMT > 0 THEN DESKTOP_AMT ELSE 0 END) AS TOTAL_AMOUNT, COUNT(CASE WHEN MOBILE_AMT = 0 AND DESKTOP_AMT > 0 THEN 1 END) AS TOTAL_USERS FROM TEMP GROUP BY SPEND_DATE) UNION ALL (SELECT SPEND_DATE, 'BOTH' AS PLATFORM, SUM(CASE WHEN MOBILE_AMT > 0 AND DESKTOP_AMT > 0 THEN MOBILE_AMT+DESKTOP_AMT ELSE 0 END) AS TOTAL_AMOUNT, COUNT(CASE WHEN MOBILE_AMT > 0 AND DESKTOP_AMT > 0 THEN 1 END) AS TOTAL_USERS FROM TEMP GROUP BY SPEND_DATE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT ACTIVITY_DATE DAY, COUNT(DISTINCT USER_ID) ACTIVE_USERS FROM ACTIVITY GROUP BY ACTIVITY_DATE HAVING ACTIVITY_DATE > DATE_ADD('2019-07-27', INTERVAL -30 DAY) AND ACTIVITY_DATE <= '2019-07-27';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT(ARTICLE_ID)) > 1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEW_DATE, VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CT FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING CT > 1 ) A ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE ) SELECT DISTINCT VIEWER_ID AS ID FROM CTE WHERE CNT > 1 ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable QUERIES, Columns = [ *, QUERY_NAME, RESULT, POSITION, RATING ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT QUERY_NAME, ROUND(AVG(RATING/POSITION), 2) AS QUALITY, ROUND(100*SUM(CASE WHEN RATING<3 THEN 1 ELSE 0 END)/COUNT(1), 2) AS POOR_QUERY_PERCENTAGE FROM QUERIES GROUP BY QUERY_NAME;\n[SQL_2] SELECT QUERY_NAME , ROUND(AVG(R),2) AS QUALITY, ROUND(SUM(CASE WHEN RATING < 3 THEN 1 ELSE 0 END)/COUNT(RATING)*100,2) AS POOR_QUERY_PERCENTAGE FROM( SELECT * , RATING/POSITION AS R FROM QUERIES )A GROUP BY QUERY_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS P JOIN UNITSSOLD AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TOTALPURCHASE AS ( SELECT PRI.PRODUCT_ID ,SUM(PRICE*UNITS) AS TOTALPRICE ,SUM(UNITS) AS TOTALUNITS FROM PRICES AS PRI JOIN UNITSSOLD AS US ON PRI.PRODUCT_ID = US.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY PRI.PRODUCT_ID ) SELECT PRODUCT_ID ,ROUND(TOTALPRICE/TOTALUNITS,2) AS AVERAGE_PRICE FROM TOTALPURCHASE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND((SUM(PRICE*UNITS) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES AS P JOIN UNITSSOLD AS US ON P.PRODUCT_ID =US.PRODUCT_ID AND (US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID ,ROUND(SUM(PRICE*UNITS)/SUM(UNITS), 2) AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FRIENDSHIP.USER1_ID, LIKES.USER_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = '1') AND ( USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = '1') OR USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = '1') );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FRIENDSHIP.USER1_ID, LIKES.USER_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDLIST AS (SELECT USER2_ID AS FRIENDS FROM FRIENDSHIP WHERE USER1_ID=1 UNION ALL SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT * FROM FRIENDLIST) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ]\nPrimary Keys = [ FRIENDSHIP.USER1_ID, LIKES.USER_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN FRIENDSHIP F ON ((L.USER_ID=F.USER2_ID AND F.USER1_ID=1) OR (L.USER_ID=F.USER1_ID AND F.USER2_ID=1)) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ EMPLOYEEUNI.ID = EMPLOYEES.ID ]\nPrimary Keys = [ EMPLOYEES.ID, EMPLOYEEUNI.ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EUNI.UNIQUE_ID, EMP.NAME FROM EMPLOYEES AS EMP LEFT JOIN EMPLOYEEUNI AS EUNI ON EMP.ID = EUNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT A.CUSTOMER_ID, C.CUSTOMER_NAME FROM (SELECT O1.CUSTOMER_ID FROM ORDERS O1 WHERE O1.PRODUCT_NAME = 'A') A JOIN (SELECT O2.CUSTOMER_ID FROM ORDERS O2 WHERE O2.PRODUCT_NAME = 'B') B ON A.CUSTOMER_ID = B.CUSTOMER_ID JOIN CUSTOMERS C ON A.CUSTOMER_ID = C.CUSTOMER_ID WHERE A.CUSTOMER_ID NOT IN (SELECT O3.CUSTOMER_ID FROM ORDERS O3 WHERE O3.PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID,C.CUSTOMER_NAME FROM CUSTOMERS AS C JOIN ORDERS AS O ON C.CUSTOMER_ID=O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A' ) AND O.CUSTOMER_ID IN( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B' ) AND O.CUSTOMER_ID NOT IN( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C1.CUSTOMER_ID, C1.CUSTOMER_NAME FROM CUSTOMERS C1 JOIN ORDERS O1 ON C1.CUSTOMER_ID = O1.CUSTOMER_ID JOIN ORDERS O2 ON O1.CUSTOMER_ID = O2.CUSTOMER_ID AND O1.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B' LEFT JOIN ORDERS O3 ON O3.CUSTOMER_ID = O2.CUSTOMER_ID AND O3.PRODUCT_NAME = 'C' WHERE O3.CUSTOMER_ID IS NULL ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C INNER JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID NOT IN( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' ) AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH BOUGHTA AS (SELECT DISTINCT C.CUSTOMER_ID AS ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A'), BOUGHTB AS (SELECT DISTINCT C.CUSTOMER_ID AS ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'B'), BOUGHTC AS (SELECT DISTINCT C.CUSTOMER_ID AS ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'C') SELECT DISTINCT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID IN (SELECT BOUGHTA.ID FROM BOUGHTA) AND C.CUSTOMER_ID IN (SELECT BOUGHTB.ID FROM BOUGHTB) AND C.CUSTOMER_ID NOT IN (SELECT BOUGHTC.ID FROM BOUGHTC);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTEC AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'), CTEB AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') SELECT T.CUSTOMER_ID, C.CUSTOMER_NAME FROM (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE (PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT * FROM CTEB) AND CUSTOMER_ID NOT IN (SELECT * FROM CTEC))T LEFT JOIN CUSTOMERS C ON T.CUSTOMER_ID = C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable NPV, Columns = [ *, ID, YEAR, NPV ]\nTable QUERIES, Columns = [ *, ID, YEAR ]\n\nForeign Keys = [ QUERIES.ID = NPV.ID ]\nPrimary Keys = [ NPV.ID, QUERIES.ID ]\n\n### SQL\n[SQL_1] SELECT Q.ID, Q.YEAR, IFNULL(N.NPV,0) AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND Q.YEAR = N.YEAR;\n[SQL_2] SELECT Q.ID, Q.YEAR, IFNULL(NPV, 0) AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND N.YEAR = Q.YEAR;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable NPV, Columns = [ *, ID, YEAR, NPV ]\nTable QUERIES, Columns = [ *, ID, YEAR ]\n\nForeign Keys = [ QUERIES.ID = NPV.ID ]\nPrimary Keys = [ NPV.ID, QUERIES.ID ]\n\n### SQL\n[SQL_1] SELECT Q.ID, Q.YEAR, IFNULL(N.NPV,0) AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND Q.YEAR = N.YEAR;\n[SQL_2] SELECT Q.ID,Q.YEAR,IFNULL(N.NPV,0) AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND N.YEAR = Q.YEAR;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable NPV, Columns = [ *, ID, YEAR, NPV ]\nTable QUERIES, Columns = [ *, ID, YEAR ]\n\nForeign Keys = [ QUERIES.ID = NPV.ID ]\nPrimary Keys = [ NPV.ID, QUERIES.ID ]\n\n### SQL\n[SQL_1] SELECT Q.ID, Q.YEAR, IFNULL(N.NPV,0) AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND Q.YEAR = N.YEAR;\n[SQL_2] SELECT Q.ID, Q.YEAR, CASE WHEN N.NPV THEN N.NPV ELSE 0 END AS NPV FROM QUERIES Q LEFT JOIN NPV N ON Q.ID = N.ID AND Q.YEAR = N.YEAR GROUP BY 1, 2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SESSIONS.SESSION_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(IF((DURATION / 60) < 5, 1, NULL)) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, COUNT(IF((DURATION / 60) < 10 AND (DURATION / 60) >= 5, 1, NULL)) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, COUNT(IF((DURATION / 60) < 15 AND (DURATION / 60) >= 10, 1, NULL)) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, COUNT(IF((DURATION / 60) >= 15, 1, NULL)) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SALARIES.COMPANY_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH SAL_MAX AS (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) SELECT A.COMPANY_ID,A.EMPLOYEE_ID,A.EMPLOYEE_NAME,ROUND(CASE WHEN MAX_SAL < 1000 THEN SALARY WHEN MAX_SAL >= 1000 AND MAX_SAL <= 10000 THEN (SALARY - SALARY*0.24) ELSE (SALARY - SALARY*0.49) END,0) AS SALARY FROM SALARIES A INNER JOIN SAL_MAX B ON A.COMPANY_ID = B.COMPANY_ID GROUP BY A.COMPANY_ID,A.EMPLOYEE_ID,A.EMPLOYEE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SALARIES.COMPANY_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH P AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) > 10000 THEN 0.49 ELSE 0.24 END AS TAX FROM SALARIES GROUP BY 1 ) SELECT S.COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME, ROUND(SALARY -(TAX*SALARY)) AS SALARY FROM SALARIES S JOIN P ON S.COMPANY_ID = P.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC, V.CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID,COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable USERS, Columns = [ *, ACCOUNT, NAME ]\nTable TRANSACTIONS, Columns = [ *, TRANS_ID, ACCOUNT, AMOUNT, TRANSACTED_ON ]\n\nForeign Keys = [ TRANSACTIONS.ACCOUNT = USERS.ACCOUNT ]\nPrimary Keys = [ USERS.ACCOUNT, USERS.NAME, TRANSACTIONS.TRANS_ID ]\n\n### SQL\n[SQL_1] SELECT U.NAME,SUM(T.AMOUNT) AS BALANCE FROM USERS U,TRANSACTIONS T WHERE U.ACCOUNT = T.ACCOUNT GROUP BY T.ACCOUNT HAVING SUM(T.AMOUNT) > 10000;\n[SQL_2] SELECT U.NAME AS NAME, SUM(T.AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT GROUP BY U.NAME HAVING SUM(T.AMOUNT)> 10000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable USERS, Columns = [ *, ACCOUNT, NAME ]\nTable TRANSACTIONS, Columns = [ *, TRANS_ID, ACCOUNT, AMOUNT, TRANSACTED_ON ]\n\nForeign Keys = [ TRANSACTIONS.ACCOUNT = USERS.ACCOUNT ]\nPrimary Keys = [ USERS.ACCOUNT, USERS.NAME, TRANSACTIONS.TRANS_ID ]\n\n### SQL\n[SQL_1] SELECT U.NAME,SUM(T.AMOUNT) AS BALANCE FROM USERS U,TRANSACTIONS T WHERE U.ACCOUNT = T.ACCOUNT GROUP BY T.ACCOUNT HAVING SUM(T.AMOUNT) > 10000;\n[SQL_2] WITH TEMP AS(SELECT ACCOUNT, SUM(AMOUNT) BALANCE FROM TRANSACTIONS GROUP BY ACCOUNT) SELECT NAME, BALANCE FROM TEMP INNER JOIN USERS ON TEMP.ACCOUNT = USERS.ACCOUNT WHERE BALANCE > 10000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable USERS, Columns = [ *, ACCOUNT, NAME ]\nTable TRANSACTIONS, Columns = [ *, TRANS_ID, ACCOUNT, AMOUNT, TRANSACTED_ON ]\n\nForeign Keys = [ TRANSACTIONS.ACCOUNT = USERS.ACCOUNT ]\nPrimary Keys = [ USERS.ACCOUNT, USERS.NAME, TRANSACTIONS.TRANS_ID ]\n\n### SQL\n[SQL_1] SELECT U.NAME,SUM(T.AMOUNT) AS BALANCE FROM USERS U,TRANSACTIONS T WHERE U.ACCOUNT = T.ACCOUNT GROUP BY T.ACCOUNT HAVING SUM(T.AMOUNT) > 10000;\n[SQL_2] SELECT NAME, SUM(AMOUNT) AS BALANCE FROM USERS LEFT JOIN TRANSACTIONS USING (ACCOUNT) GROUP BY NAME HAVING BALANCE > 10000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable USERS, Columns = [ *, ACCOUNT, NAME ]\nTable TRANSACTIONS, Columns = [ *, TRANS_ID, ACCOUNT, AMOUNT, TRANSACTED_ON ]\n\nForeign Keys = [ TRANSACTIONS.ACCOUNT = USERS.ACCOUNT ]\nPrimary Keys = [ USERS.ACCOUNT, USERS.NAME, TRANSACTIONS.TRANS_ID ]\n\n### SQL\n[SQL_1] SELECT U.NAME,SUM(T.AMOUNT) AS BALANCE FROM USERS U,TRANSACTIONS T WHERE U.ACCOUNT = T.ACCOUNT GROUP BY T.ACCOUNT HAVING SUM(T.AMOUNT) > 10000;\n[SQL_2] SELECT U.NAME , SUM(AMOUNT) AS BALANCE FROM USERS U JOIN TRANSACTIONS T ON U.ACCOUNT = T.ACCOUNT GROUP BY U.NAME HAVING BALANCE >10000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT A.MACHINE_ID, ROUND(AVG(B.TIMESTAMP-A.TIMESTAMP),3) AS PROCESSING_TIME FROM ACTIVITY A JOIN ACTIVITY B ON A.MACHINE_ID = B.MACHINE_ID AND A.PROCESS_ID = B.PROCESS_ID AND (A.ACTIVITY_TYPE = 'START' AND B.ACTIVITY_TYPE = 'END') GROUP BY MACHINE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP - S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID ORDER BY S.MACHINE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT MACHINE_ID, ROUND(AVG(PROCESS_TIME),3) AS PROCESSING_TIME FROM ( SELECT E.MACHINE_ID, E.PROCESS_ID, (E.TIMESTAMP - S.TIMESTAMP) AS PROCESS_TIME FROM ACTIVITY E JOIN ACTIVITY S USING(MACHINE_ID, PROCESS_ID) WHERE E.ACTIVITY_TYPE = 'END' AND S.ACTIVITY_TYPE = 'START' )PT GROUP BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, NAME ]\nTable INVOICE, Columns = [ *, INVOICE_ID, PRODUCT_ID, REST, PAID, CANCELED, REFUNDED ]\n\nForeign Keys = [ INVOICE.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID, PRODUCT.NAME, INVOICE.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT P.NAME AS NAME, IFNULL(SUM(REST), 0) AS REST, IFNULL(SUM(PAID), 0) AS PAID, IFNULL(SUM(CANCELED),0) AS CANCELED, IFNULL(SUM(REFUNDED),0) AS REFUNDED FROM INVOICE I RIGHT JOIN PRODUCT P ON P.PRODUCT_ID = I.PRODUCT_ID GROUP BY P.NAME ORDER BY P.NAME;\n[SQL_2] SELECT NAME ,COALESCE(SUM(REST),0) AS REST ,COALESCE(SUM(PAID),0) AS PAID ,COALESCE(SUM(CANCELED),0) AS CANCELED ,COALESCE(SUM(REFUNDED),0) AS REFUNDED FROM PRODUCT P LEFT JOIN INVOICE I ON P.PRODUCT_ID = I.PRODUCT_ID GROUP BY NAME ORDER BY NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, NAME ]\nTable INVOICE, Columns = [ *, INVOICE_ID, PRODUCT_ID, REST, PAID, CANCELED, REFUNDED ]\n\nForeign Keys = [ INVOICE.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID, PRODUCT.NAME, INVOICE.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT P.NAME AS NAME, IFNULL(SUM(REST), 0) AS REST, IFNULL(SUM(PAID), 0) AS PAID, IFNULL(SUM(CANCELED),0) AS CANCELED, IFNULL(SUM(REFUNDED),0) AS REFUNDED FROM INVOICE I RIGHT JOIN PRODUCT P ON P.PRODUCT_ID = I.PRODUCT_ID GROUP BY P.NAME ORDER BY P.NAME;\n[SQL_2] SELECT P.NAME AS NAME, COALESCE(SUM(I.REST),0) AS REST, COALESCE(SUM(I.PAID), 0) AS PAID, COALESCE(SUM(I.CANCELED),0) AS CANCELED, COALESCE(SUM(I.REFUNDED),0) AS REFUNDED FROM PRODUCT AS P LEFT JOIN INVOICE AS I ON P.PRODUCT_ID = I.PRODUCT_ID GROUP BY P.PRODUCT_ID ORDER BY P.NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CHESTS, Columns = [ *, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\nTable BOXES, Columns = [ *, BOX_ID, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\n\nForeign Keys = [ BOXES.CHEST_ID = CHESTS.CHEST_ID ]\nPrimary Keys = [ BOXES.BOX_ID, CHESTS.CHEST_ID ]\n\n### SQL\n[SQL_1] SELECT SUM(B.APPLE_COUNT + IFNULL(C.APPLE_COUNT, 0)) AS APPLE_COUNT , SUM(B.ORANGE_COUNT + IFNULL(C.ORANGE_COUNT,0)) AS ORANGE_COUNT FROM BOXES B LEFT JOIN CHESTS C ON B.CHEST_ID = C.CHEST_ID;\n[SQL_2] SELECT SUM(APPLE_COUNT) AS APPLE_COUNT, SUM(ORANGE_COUNT) AS ORANGE_COUNT FROM (SELECT APPLE_COUNT, ORANGE_COUNT FROM BOXES UNION ALL SELECT C.APPLE_COUNT, C.ORANGE_COUNT FROM BOXES B LEFT JOIN CHESTS C ON B.CHEST_ID = C.CHEST_ID)A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CHESTS, Columns = [ *, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\nTable BOXES, Columns = [ *, BOX_ID, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\n\nForeign Keys = [ BOXES.CHEST_ID = CHESTS.CHEST_ID ]\nPrimary Keys = [ BOXES.BOX_ID, CHESTS.CHEST_ID ]\n\n### SQL\n[SQL_1] SELECT SUM(B.APPLE_COUNT + IFNULL(C.APPLE_COUNT, 0)) AS APPLE_COUNT , SUM(B.ORANGE_COUNT + IFNULL(C.ORANGE_COUNT,0)) AS ORANGE_COUNT FROM BOXES B LEFT JOIN CHESTS C ON B.CHEST_ID = C.CHEST_ID;\n[SQL_2] WITH TMP AS( SELECT A.BOX_ID , A.CHEST_ID , CASE WHEN A.CHEST_ID IS NULL THEN A.APPLE_COUNT ELSE A.APPLE_COUNT+B.APPLE_COUNT END AS TOTAL_APPLE , CASE WHEN A.CHEST_ID IS NULL THEN A.ORANGE_COUNT ELSE A.ORANGE_COUNT+B.ORANGE_COUNT END AS TOTAL_ORANGE FROM BOXES A LEFT JOIN CHESTS B ON A.CHEST_ID = B.CHEST_ID) SELECT SUM(TOTAL_APPLE) AS APPLE_COUNT , SUM(TOTAL_ORANGE) AS ORANGE_COUNT FROM TMP;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT E1.EMPLOYEE_ID,E1.NAME,COUNT(E1.EMPLOYEE_ID)AS REPORTS_COUNT, ROUND(AVG(E2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES E1 INNER JOIN EMPLOYEES E2 ON E1.EMPLOYEE_ID=E2.REPORTS_TO GROUP BY E1.EMPLOYEE_ID ORDER BY E1.EMPLOYEE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT M.EMPLOYEE_ID, M.NAME, COUNT(E.EMPLOYEE_ID) REPORTS_COUNT , ROUND(AVG(E.AGE)) AVERAGE_AGE FROM EMPLOYEES M INNER JOIN EMPLOYEES E ON E.REPORTS_TO = M.EMPLOYEE_ID GROUP BY M.EMPLOYEE_ID, M.NAME ORDER BY M.EMPLOYEE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT E1.EMPLOYEE_ID, E1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(IFNULL(AVG(E2.AGE), 0)) AS AVERAGE_AGE FROM EMPLOYEES E1 JOIN EMPLOYEES E2 ON E1.EMPLOYEE_ID = E2.REPORTS_TO GROUP BY 1, 2 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT E2.EMPLOYEE_ID, E2.NAME, COUNT(E1.EMPLOYEE_ID) AS REPORTS_COUNT, ROUND(SUM(E1.AGE)/COUNT(*),0) AS AVERAGE_AGE FROM EMPLOYEES E1, EMPLOYEES E2 WHERE E1.REPORTS_TO = E2.EMPLOYEE_ID GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT E1.EMPLOYEE_ID, E1.NAME, COUNT(DISTINCT E2.EMPLOYEE_ID) AS REPORTS_COUNT, ROUND(AVG(E2.AGE)) AS AVERAGE_AGE FROM EMPLOYEES E1 JOIN EMPLOYEES E2 ON E1.EMPLOYEE_ID = E2.REPORTS_TO GROUP BY 1,2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS <> B.IP_ADDRESS AND B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE, PRICE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ PRODUCTS.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT PRODUCT_ID, SUM(CASE WHEN STORE = 'STORE1' THEN PRICE ELSE NULL END) AS STORE1, SUM(CASE WHEN STORE = 'STORE2' THEN PRICE ELSE NULL END) AS STORE2, SUM(CASE WHEN STORE = 'STORE3' THEN PRICE ELSE NULL END) AS STORE3 FROM PRODUCTS GROUP BY 1;\n[SQL_2] SELECT R.PRODUCT_ID, SUM(R.STORE1) AS STORE1, SUM(R.STORE2) AS STORE2, SUM(R.STORE3) AS STORE3 FROM (SELECT PRODUCT_ID, CASE WHEN STORE = 'STORE1' THEN PRICE END AS STORE1, CASE WHEN STORE = 'STORE2' THEN PRICE END AS STORE2, CASE WHEN STORE = 'STORE3' THEN PRICE END AS STORE3 FROM PRODUCTS) R GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYERS, Columns = [ *, PLAYER_ID, PLAYER_NAME ]\nTable CHAMPIONSHIPS, Columns = [ *, YEAR, WIMBLEDON, FR_OPEN, US_OPEN, AU_OPEN ]\n\nForeign Keys = [ CHAMPIONSHIPS.WIMBLEDON = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.FR_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.US_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.AU_OPEN = PLAYERS.PLAYER_ID ]\nPrimary Keys = [ PLAYERS.PLAYER_ID, CHAMPIONSHIPS.YEAR ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PLAYER_ID, PLAYER_NAME, SUM((CASE WHEN PLAYER_ID = WIMBLEDON THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = FR_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = US_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = AU_OPEN THEN 1 ELSE 0 END)) AS GRAND_SLAMS_COUNT FROM PLAYERS CROSS JOIN CHAMPIONSHIPS GROUP BY PLAYER_ID) AS Z WHERE GRAND_SLAMS_COUNT > 0;\n[SQL_2] SELECT PLAYER_ID, PLAYER_NAME, SUM(PLAYER_ID = WIMBLEDON) + SUM(PLAYER_ID = FR_OPEN) + SUM(PLAYER_ID = US_OPEN) + SUM(PLAYER_ID = AU_OPEN) AS GRAND_SLAMS_COUNT FROM PLAYERS P JOIN CHAMPIONSHIPS C ON PLAYER_ID = WIMBLEDON OR PLAYER_ID = FR_OPEN OR PLAYER_ID = US_OPEN OR PLAYER_ID = AU_OPEN GROUP BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYERS, Columns = [ *, PLAYER_ID, PLAYER_NAME ]\nTable CHAMPIONSHIPS, Columns = [ *, YEAR, WIMBLEDON, FR_OPEN, US_OPEN, AU_OPEN ]\n\nForeign Keys = [ CHAMPIONSHIPS.WIMBLEDON = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.FR_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.US_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.AU_OPEN = PLAYERS.PLAYER_ID ]\nPrimary Keys = [ PLAYERS.PLAYER_ID, CHAMPIONSHIPS.YEAR ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PLAYER_ID, PLAYER_NAME, SUM((CASE WHEN PLAYER_ID = WIMBLEDON THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = FR_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = US_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = AU_OPEN THEN 1 ELSE 0 END)) AS GRAND_SLAMS_COUNT FROM PLAYERS CROSS JOIN CHAMPIONSHIPS GROUP BY PLAYER_ID) AS Z WHERE GRAND_SLAMS_COUNT > 0;\n[SQL_2] SELECT P.PLAYER_ID, P.PLAYER_NAME, SUM(IF(C.WIMBLEDON = P.PLAYER_ID, 1, 0) + IF(C.FR_OPEN = P.PLAYER_ID, 1, 0) + IF(C.US_OPEN = P.PLAYER_ID, 1, 0) + IF(C.AU_OPEN = P.PLAYER_ID, 1, 0)) GRAND_SLAMS_COUNT FROM PLAYERS P, CHAMPIONSHIPS C GROUP BY 1, 2 HAVING GRAND_SLAMS_COUNT > 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYERS, Columns = [ *, PLAYER_ID, PLAYER_NAME ]\nTable CHAMPIONSHIPS, Columns = [ *, YEAR, WIMBLEDON, FR_OPEN, US_OPEN, AU_OPEN ]\n\nForeign Keys = [ CHAMPIONSHIPS.WIMBLEDON = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.FR_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.US_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.AU_OPEN = PLAYERS.PLAYER_ID ]\nPrimary Keys = [ PLAYERS.PLAYER_ID, CHAMPIONSHIPS.YEAR ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PLAYER_ID, PLAYER_NAME, SUM((CASE WHEN PLAYER_ID = WIMBLEDON THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = FR_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = US_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = AU_OPEN THEN 1 ELSE 0 END)) AS GRAND_SLAMS_COUNT FROM PLAYERS CROSS JOIN CHAMPIONSHIPS GROUP BY PLAYER_ID) AS Z WHERE GRAND_SLAMS_COUNT > 0;\n[SQL_2] WITH CTE AS ( SELECT WIMBLEDON AS PLAYER_ID, COUNT(*) AS WINS FROM CHAMPIONSHIPS GROUP BY 1 UNION ALL SELECT FR_OPEN AS PLAYER_ID, COUNT(*) AS WINS FROM CHAMPIONSHIPS GROUP BY 1 UNION ALL SELECT US_OPEN AS PLAYER_ID, COUNT(*) AS WINS FROM CHAMPIONSHIPS GROUP BY 1 UNION ALL SELECT AU_OPEN AS PLAYER_ID, COUNT(*) AS WINS FROM CHAMPIONSHIPS GROUP BY 1 ), CTE2 AS ( SELECT PLAYER_ID, SUM(WINS) AS GRAND_SLAMS_COUNT FROM CTE GROUP BY 1 ) SELECT A.PLAYER_ID, PLAYER_NAME, GRAND_SLAMS_COUNT FROM CTE2 A LEFT JOIN PLAYERS B ON A.PLAYER_ID = B.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYERS, Columns = [ *, PLAYER_ID, PLAYER_NAME ]\nTable CHAMPIONSHIPS, Columns = [ *, YEAR, WIMBLEDON, FR_OPEN, US_OPEN, AU_OPEN ]\n\nForeign Keys = [ CHAMPIONSHIPS.WIMBLEDON = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.FR_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.US_OPEN = PLAYERS.PLAYER_ID, CHAMPIONSHIPS.AU_OPEN = PLAYERS.PLAYER_ID ]\nPrimary Keys = [ PLAYERS.PLAYER_ID, CHAMPIONSHIPS.YEAR ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PLAYER_ID, PLAYER_NAME, SUM((CASE WHEN PLAYER_ID = WIMBLEDON THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = FR_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = US_OPEN THEN 1 ELSE 0 END + CASE WHEN PLAYER_ID = AU_OPEN THEN 1 ELSE 0 END)) AS GRAND_SLAMS_COUNT FROM PLAYERS CROSS JOIN CHAMPIONSHIPS GROUP BY PLAYER_ID) AS Z WHERE GRAND_SLAMS_COUNT > 0;\n[SQL_2] WITH CTE AS ( SELECT YEAR, WIMBLEDON AS GRAND_SLAMS FROM CHAMPIONSHIPS UNION ALL SELECT YEAR, FR_OPEN AS GRAND_SLAMS FROM CHAMPIONSHIPS UNION ALL SELECT YEAR, US_OPEN AS GRAND_SLAMS FROM CHAMPIONSHIPS UNION ALL SELECT YEAR, AU_OPEN AS GRAND_SLAMS FROM CHAMPIONSHIPS ) SELECT P.PLAYER_ID, P.PLAYER_NAME, COUNT(CTE.GRAND_SLAMS) AS GRAND_SLAMS_COUNT FROM PLAYERS P JOIN CTE ON P.PLAYER_ID = CTE.GRAND_SLAMS GROUP BY PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, DEPARTMENT_ID, PRIMARY_FLAG ]\n\nForeign Keys = [ ]\nPrimary Keys = [ EMPLOYEE.EMPLOYEE_ID, EMPLOYEE.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE GROUP BY EMPLOYEE_ID HAVING COUNT(*) = 1 UNION SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE WHERE PRIMARY_FLAG = 'Y';\n[SQL_2] SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE GROUP BY EMPLOYEE_ID HAVING COUNT(EMPLOYEE_ID) = 1 UNION SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE WHERE PRIMARY_FLAG = 'Y';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, DEPARTMENT_ID, PRIMARY_FLAG ]\n\nForeign Keys = [ ]\nPrimary Keys = [ EMPLOYEE.EMPLOYEE_ID, EMPLOYEE.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE GROUP BY EMPLOYEE_ID HAVING COUNT(*) = 1 UNION SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE WHERE PRIMARY_FLAG = 'Y';\n[SQL_2] (SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE WHERE PRIMARY_FLAG='Y') UNION ALL (SELECT EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEE WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EMPLOYEE WHERE PRIMARY_FLAG='Y'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ]\nPrimary Keys = [ PRODUCTS.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) A WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ]\nPrimary Keys = [ PRODUCTS.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT P.PRODUCT_ID, 'STORE1' AS STORE, P2.STORE1 AS PRICE FROM PRODUCTS P JOIN PRODUCTS P2 ON P.PRODUCT_ID = P2.PRODUCT_ID AND P2.STORE1 IS NOT NULL UNION SELECT P.PRODUCT_ID, 'STORE2' AS STORE, P2.STORE2 AS PRICE FROM PRODUCTS P JOIN PRODUCTS P2 ON P.PRODUCT_ID = P2.PRODUCT_ID AND P2.STORE2 IS NOT NULL UNION SELECT P.PRODUCT_ID, 'STORE3' AS STORE, P2.STORE3 AS PRICE FROM PRODUCTS P JOIN PRODUCTS P2 ON P.PRODUCT_ID = P2.PRODUCT_ID AND P2.STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYBACK, Columns = [ *, SESSION_ID, CUSTOMER_ID, START_TIME, END_TIME ]\nTable ADS, Columns = [ *, AD_ID, CUSTOMER_ID, TIMESTAMP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT SESSION_ID FROM PLAYBACK PB LEFT JOIN ADS AD ON PB.CUSTOMER_ID = AD.CUSTOMER_ID AND AD.TIMESTAMP BETWEEN START_TIME AND END_TIME WHERE AD.CUSTOMER_ID IS NULL;\n[SQL_2] SELECT SESSION_ID FROM PLAYBACK WHERE SESSION_ID NOT IN ( SELECT DISTINCT SESSION_ID FROM PLAYBACK P JOIN ADS A ON P.CUSTOMER_ID = A.CUSTOMER_ID AND TIMESTAMP BETWEEN START_TIME AND END_TIME);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYBACK, Columns = [ *, SESSION_ID, CUSTOMER_ID, START_TIME, END_TIME ]\nTable ADS, Columns = [ *, AD_ID, CUSTOMER_ID, TIMESTAMP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT SESSION_ID FROM PLAYBACK PB LEFT JOIN ADS AD ON PB.CUSTOMER_ID = AD.CUSTOMER_ID AND AD.TIMESTAMP BETWEEN START_TIME AND END_TIME WHERE AD.CUSTOMER_ID IS NULL;\n[SQL_2] SELECT DISTINCT SESSION_ID FROM PLAYBACK WHERE SESSION_ID NOT IN ( SELECT SESSION_ID FROM PLAYBACK P,ADS A WHERE P.CUSTOMER_ID=A.CUSTOMER_ID AND TIMESTAMP BETWEEN START_TIME AND END_TIME );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYBACK, Columns = [ *, SESSION_ID, CUSTOMER_ID, START_TIME, END_TIME ]\nTable ADS, Columns = [ *, AD_ID, CUSTOMER_ID, TIMESTAMP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT SESSION_ID FROM PLAYBACK PB LEFT JOIN ADS AD ON PB.CUSTOMER_ID = AD.CUSTOMER_ID AND AD.TIMESTAMP BETWEEN START_TIME AND END_TIME WHERE AD.CUSTOMER_ID IS NULL;\n[SQL_2] SELECT SESSION_ID FROM PLAYBACK P WHERE SESSION_ID NOT IN ( SELECT SESSION_ID FROM PLAYBACK P INNER JOIN ADS A ON P.CUSTOMER_ID = A.CUSTOMER_ID AND A.TIMESTAMP BETWEEN P.START_TIME AND P.END_TIME );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PLAYBACK, Columns = [ *, SESSION_ID, CUSTOMER_ID, START_TIME, END_TIME ]\nTable ADS, Columns = [ *, AD_ID, CUSTOMER_ID, TIMESTAMP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT SESSION_ID FROM PLAYBACK PB LEFT JOIN ADS AD ON PB.CUSTOMER_ID = AD.CUSTOMER_ID AND AD.TIMESTAMP BETWEEN START_TIME AND END_TIME WHERE AD.CUSTOMER_ID IS NULL;\n[SQL_2] SELECT DISTINCT SESSION_ID FROM PLAYBACK P LEFT JOIN ADS A ON (A.TIMESTAMP BETWEEN P.START_TIME AND P.END_TIME) AND P.CUSTOMER_ID = A.CUSTOMER_ID WHERE A.AD_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ]\nPrimary Keys = [ PERSON.ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT EMAIL AS EMAIL, COUNT(ID) AS NUM FROM PERSON GROUP BY EMAIL ) AS HIMAN WHERE NUM > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ BONUS.EMPID = EMPLOYEE.EMPID ]\nPrimary Keys = [ EMPLOYEE.EMPID, BONUS.EMPID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE E.EMPID NOT IN (SELECT EMPID FROM BONUS WHERE BONUS>1000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ]\nPrimary Keys = [ INSURANCE.PID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>=2) AND (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ]\nPrimary Keys = [ INSURANCE.PID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH T1 AS ( SELECT TIV_2015, 1 AS ISSATTIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID) >= 2 ), T2 AS ( SELECT LAT, LON, 1 AS ISUNIQUELOC FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE T3 LEFT JOIN T1 ON T3.TIV_2015 = T1.TIV_2015 LEFT JOIN T2 ON T3.LAT = T2.LAT AND T3.LON = T2.LON WHERE T1.ISSATTIV_2015 = 1 AND T2.ISUNIQUELOC = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ]\nPrimary Keys = [ INSURANCE.PID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(INSURANCE.TIV_2016) AS TIV_2016 FROM INSURANCE WHERE INSURANCE.TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY 1 HAVING COUNT(*)>1 ) AND (LAT,LON) IN ( SELECT LAT, LON FROM INSURANCE GROUP BY 1,2 HAVING COUNT(*) = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ]\nPrimary Keys = [ INSURANCE.PID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH CTE AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1 ) , CTE2 AS ( SELECT LAT,LON FROM INSURANCE GROUP BY 1,2 HAVING COUNT(LAT) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM CTE) AND (LAT,LON) IN (SELECT LAT,LON FROM CTE2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ WORLD.NAME ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (POPULATION > 25000000 OR AREA > 3000000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ]\nPrimary Keys = [ COURSES.STUDENT ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH AGG AS ( SELECT CLASS , COUNT(CLASS) AS NUMBER FROM COURSES GROUP BY CLASS) SELECT CLASS FROM AGG WHERE NUMBER >=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ]\nPrimary Keys = [ POINT.X ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] WITH POINT1 AS (SELECT X FROM POINT ORDER BY X), POINT2 AS (SELECT X FROM POINT ORDER BY X LIMIT 1234566 OFFSET 1) SELECT ABS(P2.X-P1.X) SHORTEST FROM POINT1 P1, POINT2 P2 WHERE ABS(P2.X-P1.X)>0 ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ]\nPrimary Keys = [ POINT.X ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1 CROSS JOIN POINT P2 WHERE P1.X != P2.X ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT IF(T.COUNT_NUM = 1, NUM, NULL) AS NUM FROM (SELECT NUM, COUNT(NUM) AS COUNT_NUM FROM MYNUMBERS GROUP BY NUM ORDER BY COUNT_NUM ASC, NUM DESC )T LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(PRODUCT_NAME = 'S8') > 0 AND SUM(PRODUCT_NAME = 'IPHONE') = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY BUYER_ID HAVING MAX(PRODUCT_NAME = 'S8') AND MAX(PRODUCT_NAME = 'IPHONE') = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID HAVING (SUM(PRODUCT_NAME = 'S8') > 0) AND (SUM(PRODUCT_NAME = 'IPHONE') = 0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT A.BUYER_ID FROM SALES AS A INNER JOIN PRODUCT AS B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT A.BUYER_ID FROM SALES AS A INNER JOIN PRODUCT AS B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(PRODUCT_NAME = 'IPHONE') = 0 AND SUM(PRODUCT_NAME = 'S8') > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(PRODUCT_NAME = 'S8') > 0 AND SUM(PRODUCT_NAME = 'IPHONE') = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(PRODUCT_NAME='IPHONE')=0 AND SUM(PRODUCT_NAME='S8')!=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY 1 HAVING SUM(PRODUCT_NAME = 'S8')>0 AND SUM(PRODUCT_NAME ='IPHONE') =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8FLAG, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPFLAG FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID) SELECT BUYER_ID FROM A WHERE S8FLAG >= 1 AND IPFLAG = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S LEFT OUTER JOIN PRODUCT P ON (S.PRODUCT_ID=P.PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P RIGHT JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT(POST_ID)) REPORT_COUNT FROM ACTIONS WHERE (ACTION_DATE = '2019-07-05' - INTERVAL 1 DAY) AND EXTRA IS NOT NULL AND (ACTION ='REPORT') GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE ='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA HAVING EXTRA IS NOT NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON , COUNT(EXTRA) REPORT_COUNT FROM ( SELECT DISTINCT POST_ID, ACTION_DATE, EXTRA FROM ACTIONS WHERE ACTION = 'REPORT' ) A WHERE DATE_ADD(A.ACTION_DATE,INTERVAL 1 DAY) = '2019-07-05' GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE='2019-07-04' GROUP BY EXTRA HAVING SUM(CASE WHEN ACTION='REPORT' THEN 1 ELSE 0 END)>0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT * FROM (SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE DATEDIFF('2019-07-05', ACTION_DATE) = 1 AND ACTION = 'REPORT' GROUP BY 1) AS TMP WHERE REPORT_REASON IS NOT NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE<'2019-07-27' AND ACTIVITY_DATE>'2019-06-27' GROUP BY ACTIVITY_DATE HAVING COUNT(SESSION_ID)>=1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE DATEDIFF('2019-07-27', ACTIVITY_DATE)< 30 GROUP BY ACTIVITY_DATE HAVING COUNT(SESSION_ID)>=1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT ACTIVITY_DATE AS DAY , COUNT(DISTINCT(USER_ID)) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE > DATE_SUB('2019-07-27', INTERVAL 30 DAY) GROUP BY ACTIVITY_DATE;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE DATEDIFF('2019-07-27', ACTIVITY_DATE) < 30 AND DATEDIFF('2019-07-27', ACTIVITY_DATE) > 0 GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, USER_ID, SESSION_ID, ACTIVITY_DATE, ACTIVITY_TYPE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT ACTIVITY_DATE AS DAY, COUNT(DISTINCT USER_ID) AS ACTIVE_USERS FROM ACTIVITY WHERE ACTIVITY_DATE BETWEEN '2019-06-28' AND '2019-07-27' GROUP BY ACTIVITY_DATE;\n[SQL_2] SELECT COUNT(DISTINCT(USER_ID)) AS ACTIVE_USERS, ACTIVITY_DATE AS DAY FROM ACTIVITY WHERE ACTIVITY_DATE > DATE_SUB('2019-07-27', INTERVAL 30 DAY) AND ACTIVITY_DATE <= '2019-07-27' GROUP BY ACTIVITY_DATE;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V2.AUTHOR_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable QUERIES, Columns = [ *, QUERY_NAME, RESULT, POSITION, RATING ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT QUERY_NAME, ROUND(AVG(RATING/POSITION), 2) AS QUALITY, ROUND(100*SUM(CASE WHEN RATING<3 THEN 1 ELSE 0 END)/COUNT(1), 2) AS POOR_QUERY_PERCENTAGE FROM QUERIES GROUP BY QUERY_NAME;\n[SQL_2] SELECT QUERY_NAME, ROUND(AVG(RATING/POSITION),2) AS QUALITY, ROUND((SUM(IF(RATING<3,1,0))/COUNT(QUERY_NAME))*100,2) AS POOR_QUERY_PERCENTAGE FROM QUERIES GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES A LEFT JOIN UNITSSOLD B ON A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE >= A.START_DATE AND B.PURCHASE_DATE <= A.END_DATE GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID AS PRODUCT_ID, ROUND((SUM(P.PRICE*U.UNITS)/SUM(U.UNITS)),2) AS AVERAGE_PRICE FROM (SELECT PRODUCT_ID,START_DATE,END_DATE,PRICE FROM PRICES)P LEFT JOIN( SELECT PRODUCT_ID,PURCHASE_DATE,UNITS FROM UNITSSOLD)U ON ((P.PRODUCT_ID = U.PRODUCT_ID) AND (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE )) GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*US.UNITS) / SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS P LEFT JOIN UNITSSOLD AS US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(PRICE * UNITS) / SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID AND DATE(PURCHASE_DATE) >= DATE(START_DATE) AND DATE(PURCHASE_DATE) <= DATE(END_DATE) GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(IFNULL(SUM(PRICE*UNITS)/SUM(UNITS),PRICE),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID ]\nPrimary Keys = [ PRICES.PRODUCT_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON UNITSSOLD.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE AND UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID, STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID ]\nPrimary Keys = [ DEPARTMENTS.ID, STUDENTS.ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON D.ID = S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID, STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID ]\nPrimary Keys = [ DEPARTMENTS.ID, STUDENTS.ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID,A.NAME FROM STUDENTS AS A LEFT JOIN DEPARTMENTS AS B ON A.DEPARTMENT_ID = B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID, STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID ]\nPrimary Keys = [ DEPARTMENTS.ID, STUDENTS.ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT S.ID ,S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID =D.ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CN.USER_ID) CONTACTS_CNT, COUNT(T.CUSTOMER_NAME) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CN ON CN.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS T ON CN.CONTACT_NAME = T.CUSTOMER_NAME GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS (SELECT USER_ID, COUNT(CONTACT_EMAIL) CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) TRUSTED_CONTACTS_CNT FROM CONTACTS GROUP BY 1) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, IFNULL(CONTACTS_CNT, 0) CONTACTS_CNT, IFNULL(TRUSTED_CONTACTS_CNT, 0) TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CTE ON I.USER_ID = CTE.USER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS( SELECT CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_EMAIL) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C LEFT JOIN CONTACTS CT ON C.CUSTOMER_ID = CT.USER_ID GROUP BY 1,2) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, IFNULL(CONTACTS_CNT,0) AS CONTACTS_CNT, IFNULL(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CTE ON I.USER_ID = CTE.CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CON ON CON.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS C2 ON C2.EMAIL = CON.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(DISTINCT CO.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(DISTINCT C2.CUSTOMER_ID) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CO ON C.CUSTOMER_ID = CO.USER_ID LEFT JOIN CUSTOMERS C2 ON CO.CONTACT_NAME = C2.CUSTOMER_NAME AND CO.CONTACT_EMAIL = C2.EMAIL GROUP BY 1,2,3 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, IFNULL(COUNT(CONTACT_NAME),0) CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CON ON I.USER_ID = CON.USER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTS_LKP AS ( SELECT CT.*, CASE WHEN CUST_EMAILS.EMAIL IS NOT NULL THEN 1 ELSE 0 END AS IS_TRUSTED FROM CONTACTS AS CT LEFT JOIN ( SELECT EMAIL FROM CUSTOMERS GROUP BY EMAIL ) AS CUST_EMAILS ON CT.CONTACT_EMAIL = CUST_EMAILS.EMAIL ) , CONTACT_INFO AS ( SELECT USER_ID, COUNT(*) AS CONTACTS_CNT, SUM(IS_TRUSTED) AS TRUSTED_CONTACTS_CNT FROM CONTACTS_LKP GROUP BY USER_ID ) SELECT I.INVOICE_ID, CT.CUSTOMER_NAME, I.PRICE, COALESCE(CI.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(CI.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I INNER JOIN CUSTOMERS AS CT ON I.USER_ID = CT.CUSTOMER_ID LEFT JOIN CONTACT_INFO AS CI ON I.USER_ID = CI.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMERS.CUSTOMER_NAME,PRICE, COUNT(CONTACTS.USER_ID) CONTACTS_CNT, SUM(CASE WHEN CONTACTS.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) TRUSTED_CONTACTS_CNT FROM INVOICES JOIN CUSTOMERS ON CUSTOMERS.CUSTOMER_ID = INVOICES.USER_ID LEFT JOIN CONTACTS ON CONTACTS.USER_ID = INVOICES.USER_ID GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CC AS ( SELECT USER_ID, COUNT(*) NUMBER FROM CONTACTS GROUP BY USER_ID ) , TC AS ( SELECT USER_ID, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TCO FROM CONTACTS GROUP BY USER_ID ) , TEMP AS ( SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, A.USER_ID FROM INVOICES A INNER JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID ) SELECT A.INVOICE_ID, A.CUSTOMER_NAME, A.PRICE, CASE WHEN B.NUMBER IS NULL THEN 0 ELSE B.NUMBER END AS CONTACTS_CNT, CASE WHEN C.TCO IS NULL THEN 0 ELSE C.TCO END AS TRUSTED_CONTACTS_CNT FROM TEMP A LEFT JOIN CC B ON A.USER_ID=B.USER_ID LEFT JOIN TC C ON A.USER_ID=C.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, IFNULL(COUNT(C.USER_ID), 0) AS CONTACTS_CNT, SUM(CASE WHEN C.CONTACT_EMAIL IN ( SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS A LEFT JOIN CUSTOMERS AS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CONTACTS AS C ON A.USER_ID = C.USER_ID GROUP BY A.INVOICE_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CC.USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CC.CONTACT_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CC ON C.CUSTOMER_ID = CC.USER_ID GROUP BY 1,2,3 ORDER BY INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID,CUST.CUSTOMER_NAME,INVOICE.PRICE, COUNT(C.USER_ID) AS CONTACTS_CNT, COALESCE(SUM(C.TRUSTED),0) AS TRUSTED_CONTACTS_CNT FROM INVOICES INVOICE JOIN CUSTOMERS CUST ON INVOICE.USER_ID = CUST.CUSTOMER_ID LEFT JOIN ( SELECT USER_ID,CONTACT_NAME, CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END AS TRUSTED FROM CONTACTS ) AS C ON CUST.CUSTOMER_ID = C.USER_ID GROUP BY 1,2,3 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CC.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C JOIN INVOICES I ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CC ON C.CUSTOMER_ID = CC.USER_ID LEFT JOIN CUSTOMERS C2 ON C2.EMAIL = CC.CONTACT_EMAIL GROUP BY 1,2,3 ORDER BY 1,2,3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, ROUND(AVG(PRICE),0) AS PRICE, COUNT(DISTINCT CONTACT_EMAIL) AS CONTACTS_CNT, SUM(IF(CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS), 1, 0)) AS TRUSTED_CONTACTS_CNT FROM INVOICES LEFT JOIN CUSTOMERS ON USER_ID=CUSTOMER_ID LEFT JOIN CONTACTS USING (USER_ID) GROUP BY INVOICE_ID, CUSTOMER_NAME ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID, INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, CONTACTS.USER_ID, INVOICES.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE1 AS ( SELECT CUST.CUSTOMER_ID, CUST.CUSTOMER_NAME, COUNT(DISTINCT CON.CONTACT_NAME) AS CONTACTS_CNT FROM CUSTOMERS CUST LEFT JOIN CONTACTS CON ON CUST.CUSTOMER_ID = CON.USER_ID GROUP BY CUST.CUSTOMER_NAME), CTE2 AS ( SELECT CUST.CUSTOMER_ID, CUST.CUSTOMER_NAME, COUNT(DISTINCT CON.CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS CUST LEFT JOIN CONTACTS CON ON CUST.CUSTOMER_ID = CON.USER_ID WHERE CON.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY CUST.CUSTOMER_NAME) SELECT I.INVOICE_ID, CTE1.CUSTOMER_NAME, I.PRICE, CTE1.CONTACTS_CNT, IFNULL(CTE2.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CTE1 ON I.USER_ID = CTE1.CUSTOMER_ID LEFT JOIN CTE2 ON I.USER_ID = CTE2.CUSTOMER_ID GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ EMPLOYEEUNI.ID = EMPLOYEES.ID ]\nPrimary Keys = [ EMPLOYEES.ID, EMPLOYEEUNI.ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT A.NAME, B.UNIQUE_ID FROM EMPLOYEES AS A LEFT JOIN EMPLOYEEUNI AS B ON A.ID=B.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ( SELECT CUSTOMER_ID, SUM( CASE WHEN PRODUCT_NAME='A' THEN 1 WHEN PRODUCT_NAME='B' THEN 1 WHEN PRODUCT_NAME='C' THEN 3 ELSE 0 END ) AS PRODUCT_SUM FROM ORDERS GROUP BY CUSTOMER_ID) TMP WHERE PRODUCT_SUM=2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID ]\nPrimary Keys = [ CUSTOMERS.CUSTOMER_ID, ORDERS.ORDER_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH AB AS (SELECT C.CUSTOMER_ID ID, C.CUSTOMER_NAME NAME FROM CUSTOMERS C JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID JOIN ORDERS O2 ON O2.CUSTOMER_ID = C.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B'), HAVEC AS (SELECT C2.CUSTOMER_ID ID2 , C2.CUSTOMER_NAME NAME2 FROM CUSTOMERS C2 JOIN ORDERS O4 ON O4.CUSTOMER_ID = C2.CUSTOMER_ID WHERE O4.PRODUCT_NAME = 'C'), JOINER AS (SELECT * FROM AB LEFT JOIN HAVEC ON AB.ID = HAVEC.ID2) SELECT ID CUSTOMER_ID , NAME CUSTOMER_NAME FROM JOINER WHERE ID2 IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT E.LEFT_OPERAND, E.OPERATOR, E.RIGHT_OPERAND, CASE WHEN E.OPERATOR = '<' THEN IF(L.VALUE < R.VALUE, 'TRUE', 'FALSE') WHEN E.OPERATOR = '>' THEN IF(L.VALUE > R.VALUE, 'TRUE', 'FALSE') ELSE IF(L.VALUE = R.VALUE, 'TRUE', 'FALSE') END AS VALUE FROM EXPRESSIONS E JOIN VARIABLES L ON E.LEFT_OPERAND = L.NAME JOIN VARIABLES R ON E.RIGHT_OPERAND = R.NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, (CASE WHEN OPERATOR = '>' THEN IF (A.VALUE > B.VALUE, 'TRUE', 'FALSE') WHEN OPERATOR = '<' THEN IF (A.VALUE < B.VALUE, 'TRUE', 'FALSE') WHEN OPERATOR = '=' THEN IF (A.VALUE = B.VALUE, 'TRUE', 'FALSE') ELSE FALSE END ) AS VALUE FROM EXPRESSIONS E JOIN VARIABLES A ON A.NAME = E.LEFT_OPERAND JOIN VARIABLES B ON B.NAME = E.RIGHT_OPERAND;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] WITH T AS ( SELECT VALUE AS LVALUE,OPERATOR,NAME LEFT_OPERAND, RIGHT_OPERAND FROM EXPRESSIONS JOIN VARIABLES ON EXPRESSIONS.LEFT_OPERAND =VARIABLES.NAME ), R AS (SELECT OPERATOR, VALUE AS RVALUE, LEFT_OPERAND, RIGHT_OPERAND FROM EXPRESSIONS JOIN VARIABLES ON EXPRESSIONS.RIGHT_OPERAND =VARIABLES.NAME ), TMP AS (SELECT T.LVALUE, T.LEFT_OPERAND,T.OPERATOR, T.RIGHT_OPERAND, R.RVALUE FROM T JOIN R ON T.LEFT_OPERAND =R.LEFT_OPERAND AND T.RIGHT_OPERAND =R.RIGHT_OPERAND AND T.OPERATOR = R.OPERATOR ) SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, CASE WHEN OPERATOR = '>' THEN IF(LVALUE > RVALUE, 'TRUE', 'FALSE' ) WHEN OPERATOR = '=' THEN IF(LVALUE = RVALUE, 'TRUE', 'FALSE') WHEN OPERATOR = '<' THEN IF(LVALUE < RVALUE, 'TRUE', 'FALSE' ) END AS VALUE FROM TMP;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT B.LEFT_OPERAND,B.OPERATOR,B.RIGHT_OPERAND, CASE WHEN B.OPERATOR= '>' THEN IF(A.VALUE>C.VALUE,'TRUE','FALSE') WHEN B.OPERATOR= '<' THEN IF(A.VALUE<C.VALUE,'TRUE','FALSE') WHEN B.OPERATOR= '=' THEN IF(A.VALUE=C.VALUE,'TRUE','FALSE') END AS VALUE FROM VARIABLES A JOIN EXPRESSIONS B ON A.NAME = B.LEFT_OPERAND JOIN VARIABLES C ON C.NAME=B.RIGHT_OPERAND;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] WITH CTE AS ( SELECT LEFT_OPERAND,OPERATOR,RIGHT_OPERAND, CASE WHEN T2.VALUE -T3.VALUE > 0 THEN '>' WHEN T2.VALUE -T3.VALUE < 0 THEN '<' ELSE '=' END AS VALUE FROM EXPRESSIONS T1 LEFT JOIN VARIABLES T2 ON T2.NAME = T1.LEFT_OPERAND LEFT JOIN VARIABLES T3 ON T3.NAME = T1.RIGHT_OPERAND) SELECT LEFT_OPERAND,OPERATOR,RIGHT_OPERAND, IF(VALUE = OPERATOR,'TRUE','FALSE') AS VALUE FROM CTE;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT E.*, CASE WHEN E.OPERATOR = '<' THEN IF(L.VALUE < R.VALUE,'TRUE','FALSE') WHEN E.OPERATOR = '>' THEN IF(L.VALUE > R.VALUE,'TRUE','FALSE') ELSE IF(L.VALUE = R.VALUE,'TRUE','FALSE') END AS VALUE FROM EXPRESSIONS E LEFT JOIN VARIABLES L ON E.LEFT_OPERAND = L.NAME LEFT JOIN VARIABLES R ON E.RIGHT_OPERAND = R.NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT E.*, CASE (CASE OPERATOR WHEN '>' THEN L.VALUE>R.VALUE WHEN '<' THEN L.VALUE<R.VALUE ELSE L.VALUE=R.VALUE END) WHEN 0 THEN FALSE ELSE TRUE END AS VALUE FROM EXPRESSIONS E JOIN VARIABLES L ON E.LEFT_OPERAND=L.NAME JOIN VARIABLES R ON E.RIGHT_OPERAND=R.NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT E.*, IF((CASE WHEN OPERATOR ='>' THEN V1.VALUE>V2.VALUE WHEN OPERATOR='=' THEN V1.VALUE=V2.VALUE ELSE V1.VALUE<V2.VALUE END)=0,'FALSE','TRUE') AS VALUE FROM EXPRESSIONS E LEFT JOIN VARIABLES V1 ON V1.NAME = E.LEFT_OPERAND LEFT JOIN VARIABLES V2 ON V2.NAME = E.RIGHT_OPERAND;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, IF(VAL = 0, 'FALSE', 'TRUE') AS VALUE FROM (WITH TEMP_TABLE AS ( SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, LEFT_VAL, VALUE AS RIGHT_VAL FROM VARIABLES V INNER JOIN ( SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, VALUE AS LEFT_VAL, NAME FROM EXPRESSIONS INNER JOIN VARIABLES ON NAME = LEFT_OPERAND) AS T ON V.NAME = T.RIGHT_OPERAND) SELECT LEFT_OPERAND, OPERATOR, RIGHT_OPERAND, CASE WHEN OPERATOR = '>' THEN (LEFT_VAL > RIGHT_VAL) WHEN OPERATOR = '<' THEN (LEFT_VAL < RIGHT_VAL) ELSE (LEFT_VAL = RIGHT_VAL) END AS VAL FROM TEMP_TABLE) AS D;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VARIABLES, Columns = [ *, NAME, VALUE ]\nTable EXPRESSIONS, Columns = [ *, LEFT_OPERAND, OPERATOR, RIGHT_OPERAND ]\n\nForeign Keys = [ EXPRESSIONS.LEFT_OPERAND = VARIABLES.NAME, EXPRESSIONS.RIGHT_OPERAND = VARIABLES.NAME ]\nPrimary Keys = [ VARIABLES.NAME, EXPRESSIONS.LEFT_OPERAND ]\n\n### SQL\n[SQL_1] SELECT A.*, CASE WHEN ((B.VALUE < C.VALUE AND A.OPERATOR = '<') OR (B.VALUE = C.VALUE AND A.OPERATOR = '=') OR (B.VALUE > C.VALUE AND A.OPERATOR = '>')) THEN TRUE ELSE FALSE END AS VALUE FROM EXPRESSIONS AS A JOIN VARIABLES AS B ON A.LEFT_OPERAND = B.NAME JOIN VARIABLES AS C ON A.RIGHT_OPERAND = C.NAME;\n[SQL_2] SELECT E.LEFT_OPERAND, E.OPERATOR, E.RIGHT_OPERAND, CASE WHEN OPERATOR = '>' THEN IF(V1.VALUE > V2.VALUE, 'TRUE', 'FALSE') WHEN OPERATOR = '<' THEN IF(V1.VALUE < V2.VALUE, 'TRUE', 'FALSE') ELSE IF(V1.VALUE = V2.VALUE, 'TRUE', 'FALSE') END AS VALUE FROM EXPRESSIONS E LEFT JOIN VARIABLES V1 ON V1.NAME = E.LEFT_OPERAND LEFT JOIN VARIABLES V2 ON V2.NAME = E.RIGHT_OPERAND;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SALARIES.COMPANY_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAXSAL (COMPANY_ID , MSALARY) AS ( SELECT COMPANY_ID, MAX(SALARY) FROM SALARIES GROUP BY COMPANY_ID ) SELECT COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME, CASE WHEN MSALARY>1000 AND MSALARY<10000 THEN ROUND((SALARY*76)/100) WHEN MSALARY>10000 THEN ROUND((SALARY*51)/100) ELSE SALARY END AS SALARY FROM (SELECT SALARIES.COMPANY_ID,SALARIES.EMPLOYEE_ID,SALARIES.EMPLOYEE_NAME, SALARIES.SALARY,MAXSAL.MSALARY FROM SALARIES,MAXSAL WHERE MAXSAL.COMPANY_ID=SALARIES.COMPANY_ID)T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ]\nPrimary Keys = [ SALARIES.COMPANY_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S1.COMPANY_ID, S1.EMPLOYEE_ID, S1.EMPLOYEE_NAME, ( CASE WHEN N.COMPANY_MAX < 1000 THEN S1.SALARY WHEN N.COMPANY_MAX >= 10000 THEN ROUND(0.51*S1.SALARY, 0) ELSE ROUND(0.76*S1.SALARY, 0) END) AS SALARY FROM SALARIES AS S1 JOIN (SELECT S2.COMPANY_ID, MAX(S2.SALARY) AS COMPANY_MAX FROM SALARIES AS S2 GROUP BY S2.COMPANY_ID) AS N ON S1.COMPANY_ID = N.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(1) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON T.VISIT_ID = V.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID ]\nPrimary Keys = [ VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISITS.VISIT_ID FROM VISITS INNER JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID ) GROUP BY (CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable USERS, Columns = [ *, ACCOUNT, NAME ]\nTable TRANSACTIONS, Columns = [ *, TRANS_ID, ACCOUNT, AMOUNT, TRANSACTED_ON ]\n\nForeign Keys = [ TRANSACTIONS.ACCOUNT = USERS.ACCOUNT ]\nPrimary Keys = [ USERS.ACCOUNT, USERS.NAME, TRANSACTIONS.TRANS_ID ]\n\n### SQL\n[SQL_1] SELECT U.NAME,SUM(T.AMOUNT) AS BALANCE FROM USERS U,TRANSACTIONS T WHERE U.ACCOUNT = T.ACCOUNT GROUP BY T.ACCOUNT HAVING SUM(T.AMOUNT) > 10000;\n[SQL_2] SELECT USERS.NAME AS NAME, BALANCES.BALANCE AS BALANCE FROM ( SELECT ACCOUNT, SUM(AMOUNT) AS BALANCE FROM TRANSACTIONS GROUP BY ACCOUNT ) AS BALANCES INNER JOIN USERS ON BALANCES.ACCOUNT = USERS.ACCOUNT WHERE BALANCE >= 10000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT E.MACHINE_ID, ROUND(SUM(E.TIMESTAMP - S.TIMESTAMP) / COUNT(E.PROCESS_ID), 3) PROCESSING_TIME FROM ACTIVITY E, ACTIVITY S WHERE E.ACTIVITY_TYPE = 'END' AND S.ACTIVITY_TYPE = 'START' AND E.MACHINE_ID = S.MACHINE_ID GROUP BY E.MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] WITH TIMES AS ( SELECT A.MACHINE_ID, A.PROCESS_ID, CASE WHEN ACTIVITY_TYPE = 'START' THEN TIMESTAMP END AS START_TIME, CASE WHEN ACTIVITY_TYPE = 'END' THEN TIMESTAMP END AS END_TIME FROM ACTIVITY A ), AVGS AS ( SELECT MACHINE_ID, PROCESS_ID, SUM(END_TIME) - SUM(START_TIME) AS TIME_DIFF FROM TIMES GROUP BY 1,2 ) SELECT MACHINE_ID, ROUND(SUM(TIME_DIFF) / COUNT(PROCESS_ID),3) AS PROCESSING_TIME FROM AVGS GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT MACHINE_ID, ROUND(AVG(CASE WHEN ACTIVITY_TYPE = 'START' THEN 0-TIMESTAMP ELSE TIMESTAMP END)*2 ,3) AS PROCESSING_TIME FROM ACTIVITY GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT T1.MACHINE_ID, ROUND(AVG(T2.TIMESTAMP - T1.TIMESTAMP),3) AS PROCESSING_TIME FROM ACTIVITY T1 JOIN ACTIVITY T2 ON T1.MACHINE_ID = T2.MACHINE_ID AND T1.PROCESS_ID = T2.PROCESS_ID WHERE T1.TIMESTAMP < T2.TIMESTAMP GROUP BY T1.MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] WITH A AS (SELECT A1.MACHINE_ID, A1.PROCESS_ID, (A2.TIMESTAMP - A1.TIMESTAMP) AS COUNT_TIME FROM ACTIVITY A1, ACTIVITY A2 WHERE A1.MACHINE_ID = A2.MACHINE_ID AND A1.PROCESS_ID = A2.PROCESS_ID AND A1.ACTIVITY_TYPE = 'START' AND A2.ACTIVITY_TYPE = 'END' GROUP BY A1.MACHINE_ID, A1.PROCESS_ID) SELECT MACHINE_ID, ROUND(SUM(COUNT_TIME)/COUNT(PROCESS_ID), 3) AS PROCESSING_TIME FROM A GROUP BY MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT A.MACHINE_ID, ROUND(SUM(B.TIMESTAMP - A.TIMESTAMP) / COUNT(*),3) PROCESSING_TIME FROM ACTIVITY A JOIN ACTIVITY B ON A.MACHINE_ID = B.MACHINE_ID AND A.PROCESS_ID = B.PROCESS_ID AND A.ACTIVITY_TYPE != B.ACTIVITY_TYPE WHERE A.ACTIVITY_TYPE = 'START' GROUP BY A.MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT MACHINE_ID, ROUND(AVG(T2-T1),3) AS PROCESSING_TIME FROM ( SELECT MACHINE_ID, PROCESS_ID, MIN(TIMESTAMP)T1, MAX(TIMESTAMP)T2 FROM ACTIVITY GROUP BY 1,2 ) A GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT MACHINE_ID,ROUND(SUM(TIME)/COUNT(DISTINCT PROCESS_ID),3) AS PROCESSING_TIME FROM(SELECT MACHINE_ID,PROCESS_ID, ACTIVITY_TYPE, CASE WHEN ACTIVITY_TYPE ='START' THEN -TIMESTAMP ELSE TIMESTAMP END AS TIME FROM ACTIVITY) A GROUP BY MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT A.MACHINE_ID, ROUND(AVG(A.TIMES),3) PROCESSING_TIME FROM (SELECT MACHINE_ID, SUM(CASE WHEN ACTIVITY_TYPE = 'START' THEN -TIMESTAMP ELSE TIMESTAMP END) TIMES FROM ACTIVITY GROUP BY MACHINE_ID, PROCESS_ID) A GROUP BY MACHINE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, MACHINE_ID, PROCESS_ID, ACTIVITY_TYPE, TIMESTAMP ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ACTIVITY.MACHINE_ID ]\n\n### SQL\n[SQL_1] SELECT S.MACHINE_ID, ROUND(AVG(E.TIMESTAMP-S.TIMESTAMP), 3) AS PROCESSING_TIME FROM ACTIVITY S JOIN ACTIVITY E ON S.MACHINE_ID = E.MACHINE_ID AND S.PROCESS_ID = E.PROCESS_ID AND S.ACTIVITY_TYPE = 'START' AND E.ACTIVITY_TYPE = 'END' GROUP BY S.MACHINE_ID;\n[SQL_2] SELECT MACHINE_ID, ROUND(SUM(CASE WHEN ACTIVITY_TYPE = 'START' THEN -TIMESTAMP WHEN ACTIVITY_TYPE = 'END' THEN TIMESTAMP END)/COUNT(DISTINCT PROCESS_ID),3) AS PROCESSING_TIME FROM ACTIVITY GROUP BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, NAME ]\nTable INVOICE, Columns = [ *, INVOICE_ID, PRODUCT_ID, REST, PAID, CANCELED, REFUNDED ]\n\nForeign Keys = [ INVOICE.PRODUCT_ID = PRODUCT.PRODUCT_ID ]\nPrimary Keys = [ PRODUCT.PRODUCT_ID, PRODUCT.NAME, INVOICE.INVOICE_ID ]\n\n### SQL\n[SQL_1] SELECT P.NAME AS NAME, IFNULL(SUM(REST), 0) AS REST, IFNULL(SUM(PAID), 0) AS PAID, IFNULL(SUM(CANCELED),0) AS CANCELED, IFNULL(SUM(REFUNDED),0) AS REFUNDED FROM INVOICE I RIGHT JOIN PRODUCT P ON P.PRODUCT_ID = I.PRODUCT_ID GROUP BY P.NAME ORDER BY P.NAME;\n[SQL_2] SELECT P.NAME, SUM(REST) AS REST, SUM(PAID) AS PAID, SUM(CANCELED) AS CANCELED, SUM(REFUNDED) AS REFUNDED FROM INVOICE I LEFT JOIN PRODUCT P ON I.PRODUCT_ID = P.PRODUCT_ID GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT A.DATE_ID, A.MAKE_NAME, COUNT(DISTINCT A.LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT A.PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES B LEFT JOIN DAILYSALES A ON A.DATE_ID = B.DATE_ID AND A.MAKE_NAME = B.MAKE_NAME WHERE B.LEAD_ID <= A.LEAD_ID AND B.PARTNER_ID <= A.PARTNER_ID GROUP BY A.DATE_ID, A.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CHESTS, Columns = [ *, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\nTable BOXES, Columns = [ *, BOX_ID, CHEST_ID, APPLE_COUNT, ORANGE_COUNT ]\n\nForeign Keys = [ BOXES.CHEST_ID = CHESTS.CHEST_ID ]\nPrimary Keys = [ BOXES.BOX_ID, CHESTS.CHEST_ID ]\n\n### SQL\n[SQL_1] SELECT SUM(B.APPLE_COUNT + IFNULL(C.APPLE_COUNT, 0)) AS APPLE_COUNT , SUM(B.ORANGE_COUNT + IFNULL(C.ORANGE_COUNT,0)) AS ORANGE_COUNT FROM BOXES B LEFT JOIN CHESTS C ON B.CHEST_ID = C.CHEST_ID;\n[SQL_2] SELECT SUM(APPLE_COUNT) AS APPLE_COUNT, SUM(ORANGE_COUNT) AS ORANGE_COUNT FROM ( SELECT SUM(APPLE_COUNT) AS APPLE_COUNT, SUM(ORANGE_COUNT) AS ORANGE_COUNT FROM ( SELECT A.CHEST_ID, B.APPLE_COUNT, B.ORANGE_COUNT FROM BOXES A LEFT JOIN CHESTS B ON A.CHEST_ID = B.CHEST_ID WHERE A.CHEST_ID IS NOT NULL) A UNION SELECT SUM(APPLE_COUNT) AS APPLE_COUNT, SUM(ORANGE_COUNT) AS ORANGE_COUNT FROM BOXES) B;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] WITH CTE AS (SELECT REPORTS_TO , COUNT(EMPLOYEE_ID) AS REPORTS_COUNT, ROUND(AVG(AGE)) AS AVERAGE_AGE FROM EMPLOYEES WHERE REPORTS_TO IS NOT NULL GROUP BY REPORTS_TO) SELECT A.EMPLOYEE_ID, A.NAME, REPORTS_COUNT, AVERAGE_AGE FROM CTE INNER JOIN EMPLOYEES A ON CTE.REPORTS_TO = A.EMPLOYEE_ID ORDER BY A.EMPLOYEE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, EMPLOYEE_ID, NAME, REPORTS_TO, AGE ]\n\nForeign Keys = [ EMPLOYEES.REPORTS_TO = EMPLOYEES.EMPLOYEE_ID ]\nPrimary Keys = [ EMPLOYEES.EMPLOYEE_ID ]\n\n### SQL\n[SQL_1] SELECT TB1.EMPLOYEE_ID, TB1.NAME, COUNT(*) AS REPORTS_COUNT, ROUND(AVG(TB2.AGE),0) AS AVERAGE_AGE FROM EMPLOYEES AS TB1 JOIN EMPLOYEES AS TB2 ON TB1.EMPLOYEE_ID = TB2.REPORTS_TO GROUP BY 1 ORDER BY TB1.EMPLOYEE_ID;\n[SQL_2] SELECT MGR.EMPLOYEE_ID, MGR.NAME, COUNT(EMP.EMPLOYEE_ID) AS REPORTS_COUNT, ROUND(AVG(EMP.AGE)) AS AVERAGE_AGE FROM EMPLOYEES MGR JOIN EMPLOYEES EMP ON MGR.EMPLOYEE_ID = EMP.REPORTS_TO AND MGR.EMPLOYEE_ID <> EMP.EMPLOYEE_ID GROUP BY 1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ]\nPrimary Keys = [ ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A LEFT JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID WHERE B.LOGIN > A.LOGIN AND B.LOGIN <= A.LOGOUT AND A.IP_ADDRESS <> B.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    }
]