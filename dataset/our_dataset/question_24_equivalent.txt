create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive graph_1_helper_1 AS ( SELECT playerID, yearID, teamID FROM pitching UNION SELECT playerID, yearID , teamID FROM AllstarFull WHERE GP = 1 ), players_g1h AS ( SELECT DISTINCT playerID FROM graph_1_helper_1 ) , serial_num_players AS ( SELECT ROW_NUMBER() over(ORDER BY playerID) as serial_num, playerID FROM players_g1h ) , graph_1_helper_2 AS ( SELECT a.playerID as playerID_1 , b.playerID as playerID_2, a.teamID , a.yearID FROM graph_1_helper_1 a , graph_1_helper_1  b WHERE a.teamID = b.teamID AND a.yearID = b.yearID AND a.playerID != b.playerID ) , graph_1_helper_3 AS ( SELECT playerID_1 , playerID_2 , teamID , count(yearID) as gamesplayedtogather FROM graph_1_helper_2 GROUP BY playerID_1 , playerID_2 , teamID ) , graph_1 AS ( SELECT playerID_1 , playerID_2 , sum(gamesplayedtogather) weight FROM graph_1_helper_3 GROUP BY playerID_1 , playerID_2 ORDER BY weight DESC , playerID_1 , playerID_2 ) , len_3_search AS ( SELECT playerID_1 , playerID_2 ,array[ser1.serial_num , ser2.serial_num ] as path1 ,  weight as length  , 1 as depth FROM graph_1 , serial_num_players ser1 , serial_num_players ser2 WHERE playerID_1 = 'webbbr01' AND ser1.playerID  = playerID_1 AND ser2.playerID = playerID_2 UNION ALL SELECT DISTINCT H.playerID_2 as playerID_1, E.playerID_2 as playerID_2 ,H.path1||ser1.serial_num  ,  H.length + E.weight as length, depth+1 FROM len_3_search H , serial_num_players ser1 , graph_1 E , serial_num_players ser2 , serial_num_players ser3 WHERE H.playerID_2 = E.playerID_1 AND NOT ser1.serial_num  = ANY(path1) AND ser1.playerID = E.playerID_2 AND ser2.playerID = H.playerID_2 AND ser3.playerID = 'clemero02' AND depth < 3 ) SELECT CASE WHEN 'clemero02' IN (SELECT(playerID_2) FROM len_3_search WHERE length >= 3) THEN true else false END AS pathexists
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE GRAPH1 AS (SELECT fullt1.playerid AS player1, fullt2.playerid AS player2, COUNT(fullt1.teamid) AS WEIGHT FROM (SELECT DISTINCT pitching.playerid, pitching.teamid, pitching.yearid FROM pitching FULL JOIN allstarfull ON pitching.playerid = allstarfull.playerid WHERE GP=1) fullt1 JOIN (SELECT DISTINCT pitching.playerid, pitching.teamid, pitching.yearid FROM pitching FULL JOIN allstarfull ON pitching.playerid = allstarfull.playerid WHERE GP=1) fullt2 ON fullt1.playerid != fullt2.playerid AND fullt1.teamid = fullt2.teamid AND fullt1.yearid = fullt2.yearid GROUP BY fullt1.playerid, fullt2.playerid), g2 AS ( SELECT player1, player2, Weight, ARRAY[player1::text,player2::text] AS paths FROM graph1 WHERE player1 = 'webbbr01' UNION ALL SELECT g1.player1, g1.player2, g1.weight+g2.weight AS weight, g2.paths||g1.player2::text FROM g2 JOIN graph1 AS g1 ON g1.player1 = g2.player2 AND NOT g1.player2::text=ANY(g2.paths) ) SELECT CASE WHEN (SELECT COUNT(*) FROM g2 WHERE g2.player2 = 'clemero02' AND weight>=3) > 0 THEN TRUE ELSE false END AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive players as ( select playerid, yearid, teamid from AllstarFull where GP = 1 union select playerid, yearid, teamid from Pitching ), weights as ( select player1_id, player2_id, cast(count(*) as integer) as weight from ( select p.playerid as player1_id, q.playerid as player2_id from players p join players q on p.playerid != q.playerid and p.teamid = q.teamid and p.yearid = q.yearid ) y group by player1_id, player2_id ), paths(start_player, end_player, paths, len) as ( select playerid as start_player, playerid as end_player, (playerid || '') as paths, 0 as len from players where playerid = 'webbbr01' UNION select p.start_player, q.playerid, (p.paths || ',' || q.playerid) as paths, p.len + w.weight from paths p join players tmp on p.end_player = tmp.playerid join players q on tmp.yearid = q.yearid and tmp.teamid = q.teamid and tmp.playerid != q.playerid join weights w on w.player1_id = p.end_player and w.player2_id = q.playerid where q.playerid != 'webbbr01' and p.paths not like ('%' || q.playerid || '%') and p.paths not like ('%clemero02%') and p.len + 1 <= 3 ) SELECT (COUNT(*) > 0) AS exists_path FROM paths WHERE len >= 3 and end_player = 'clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE TEMPORARY TABLE "Graph1" ( player1_number integer, edge integer, player2_number integer, len integer ); select distinct C.player_num as player1_number, count(A.teamID) as edge, D.player_num as player2_number, 1 as len into temp table Graph1 from ( select playerID, teamID, yearID from pitching union all select playerID, teamID, yearID from AllstarFull ) as A, ( select playerID, teamID, yearID from pitching union all select playerID, teamID, yearID from AllstarFull ) as B, ( select playerID, row_number() over(order by playerid) as player_num from ( select playerID from pitching union all select playerID from AllstarFull ) as T ) as C, ( select playerID, row_number() over(order by playerid) as player_num from ( select playerID from pitching union all select playerID from AllstarFull ) as T ) as D where A.teamID = B.teamID and A.yearID = B.yearID and A.playerID!=B.playerID and A.playerid = C.playerID and B.playerID = D.playerID group by A.playerID, B.playerID, C.player_num, D.player_num order by edge desc; select CASE WHEN count(*) = 0 THEN false ELSE true END AS pathexists from ( with recursive paths(player1_number, player2_number, wt, visited) as ( select distinct player1_number, player2_number, edge, array[player1_number, player2_number] as visited from Graph1 where player1_number = 9374 union all select distinct paths.player1_number, Graph1.player2_number, paths.wt+Graph1.edge, array_append(paths.visited, Graph1.player2_number) from paths, Graph1 where paths.player2_number = Graph1.player1_number and Graph1.player2_number != ALL(paths.visited) ) Select player1_number from paths where wt >= 3 and player2_number = 1617 limit 1 ) as t;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE paths(destination, length, seq) AS ( SELECT destination, length, ARRAY[source::text, destination::text] AS seq FROM graph WHERE source='webbbr01' UNION ALL SELECT graph.destination, graph.length+paths.length, seq || graph.destination::text FROM paths JOIN graph ON graph.destination::text <> ALL(seq) AND paths.destination <> 'clemero02' AND paths.destination = graph.source ), pitchers AS ( SELECT DISTINCT playerid, teamid, yearid FROM pitching UNION SELECT DISTINCT playerid, teamid, yearid FROM AllstarFull WHERE GP=1 ), graph AS ( SELECT *, COUNT(*) AS length FROM ( SELECT p1.playerid AS source, p2.playerid AS destination FROM pitchers p1 JOIN pitchers p2 ON p1.playerid != p2.playerid AND p1.teamid = p2.teamid AND p1.yearid = p2.yearid ) t GROUP BY source, destination ) SELECT MAX(length)>=3 AS pathexists FROM paths WHERE destination = 'clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
create or replace view  g1 as Select p1.playerID as p1_id ,p2.playerID  as p2_id , count(*) as edge from pitching p1 , pitching p2 where  p1.playerID != p2.playerID and p1.teamID = p2.teamID and p1.yearID = p2.yearID group by p1.playerID ,p2.playerID; create or replace view g2 as Select p1.playerID as p1_id ,p2.playerID as p2_id , count(*) as edge from AllstarFull p1 , AllstarFull p2 where  p1.playerID != p2.playerID and p1.teamID = p2.teamID and p1.yearID = p2.yearID and p1.GP = 1 AND p2.GP=1 group by p1.playerID ,p2.playerID ; create or replace view graph as ( select p1_id , p2_id , sum(edge) as edge from(   select * from g1 union ALL  select * from g2) as foo   group by p1_id , p2_id); with recursive p_dist( cur  , vis, pt_len) as ( select p2_id , array[ cast('webbbr01' as text) ]  , edge from graph where p1_id = cast('webbbr01' as text) and edge != 0 union all select p2_id , p_dist.vis|| cast(cur as text ) , p_dist.pt_len +edge from  graph join p_dist on p1_id = cur and edge!=0 and p2_id !=ALL(vis) and cast('clemero02' as text) !=ALL(vis) ) select CASE when exists (Select pt_len from p_dist where pt_len>=3 and cur = cast('clemero02' as text) ) then true else false end as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE Edge(player1 , player2 , cost) AS ( SELECT P1.playerid as player1 , P2.playerid as player2 , COUNT(P1.yearid) as cost FROM Pitching as P1 , Pitching as P2 WHERE P1.teamid=P2.teamid AND P1.yearid=P2.yearid AND P1.playerid IN (SELECT playerid FROM AllstarFull WHERE GP=1) AND P2.playerid IN (SELECT playerid FROM AllstarFull WHERE GP=1) AND P1.playerid != P2.playerid GROUP BY player1 , player2 ORDER BY player1 ASC , player2 ASC ), r_search(player1 , player2 , dist , path_) AS ( SELECT player1 , player2 , cost , ARRAY[player1] || player2 FROM Edge WHERE player1='webbbr01' UNION ALL SELECT r_search.player1 , Edge.player2 , dist + Edge.cost , r_search.path_ ||  Edge.player2 FROM r_search , Edge WHERE r_search.player2=Edge.player1 AND NOT(Edge.player2 = ANY(path_)) AND r_search.dist <= 3 AND Edge.player1 != 'clemero02' ) SELECT CASE WHEN COALESCE(max(dist),0) >=3 THEN True ELSE False END pathexists FROM r_search WHERE player2='clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE t1 AS ((SELECT DISTINCT playerID, teamID, yearID FROM AllstarFull WHERE GP = 1) UNION (SELECT DISTINCT playerID, teamID, yearID FROM Pitching)), t2 AS (SELECT x1.playerID::TEXT AS playerid1, x2.playerID::TEXT AS playerid2, COUNT(*) AS weights FROM t1 x1 JOIN t1 x2 ON x1.teamID = x2.teamID AND x1.yearID = x2.yearID WHERE x1.playerID != x2.playerID GROUP BY x1.playerID, x2.playerID ) , search_tree(playerid1, playerid2, depth, is_cycle, path_nodes) AS (SELECT playerid1, playerid2, weights, FALSE, ARRAY[playerid1, playerid2] FROM t2 WHERE playerid1 = 'webbbr01' UNION ALL SELECT st.playerid1, t2.playerid2, depth + t2.weights, t2.playerid2 = ANY(path_nodes), path_nodes || t2.playerid2 FROM t2, search_tree st WHERE t2.playerid1 = st.playerid2 AND NOT is_cycle AND st.playerid2 != 'clemero02' ) SELECT EXISTS ( SELECT * FROM search_tree WHERE playerid2 = 'clemero02' AND is_cycle = 'f' AND depth >= 3 ) AS pathexists ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE tableA AS ( SELECT DISTINCT playerid, yearid, teamid FROM Pitching ORDER BY playerid ASC, yearid ASC, teamid ASC ), tableB AS ( SELECT DISTINCT playerid, yearid, teamid FROM AllstarFull WHERE GP=1 ORDER BY playerid ASC, yearid ASC, teamid ASC ), tableC AS ( SELECT * FROM tableA UNION SELECT * FROM tableB ORDER BY playerid ASC, yearid ASC, teamid ASC ), tableD AS ( SELECT DISTINCT pa.playerid AS player1_id, pb.playerid AS player2_id, pa.yearid FROM tableC AS pa, tableC AS pb WHERE pa.playerid<>pb.playerid AND pa.yearid=pb.yearid AND pa.teamid=pb.teamid ORDER BY player1_id ASC, player2_id ASC, yearid ASC ), tableE AS ( SELECT player1_id, player2_id, COUNT(*) AS edge_weight FROM tableD GROUP BY player1_id, player2_id ORDER BY player1_id ASC, player2_id ASC ), tableF AS ( SELECT array['webbbr01', player2_id] AS arrayPath, edge_weight AS path_weight, player2_id AS lastPlayer FROM tableE WHERE player1_id='webbbr01' UNION ALL ( WITH tX AS ( SELECT array_append(arrayPath, tableE.player2_id) AS arrayPath, tableF.path_weight+tableE.edge_weight AS path_weight, tableE.player2_id AS lastPlayer FROM tableE, tableF WHERE lastPlayer=tableE.player1_id AND (NOT tableE.player2_id=ANY(arrayPath)) AND tableE.player1_id<>'clemero02' ), tY AS ( SELECT COUNT(*) AS countPaths FROM tX WHERE lastPlayer='clemero02' AND path_weight>=3 ) SELECT arrayPath, path_weight, lastPlayer FROM tX, tY WHERE countPaths=0 ) ), tableG AS ( SELECT array_append(arrayPath, tableE.player2_id) AS arrayPath, tableF.path_weight+tableE.edge_weight AS path_weight, tableE.player2_id AS lastPlayer FROM tableE, tableF WHERE lastPlayer=tableE.player1_id AND tableE.player2_id='clemero02' AND (NOT tableE.player2_id=ANY(arrayPath)) ), tableH AS ( SELECT arrayPath, path_weight FROM tableG WHERE path_weight>=3 ), tableI AS ( SELECT COUNT(*) AS countPaths FROM tableH ) SELECT CASE WHEN countPaths>0 THEN TRUE ELSE FALSE END AS pathexists FROM tableI;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive temp1(playerid, teamid, yearid) as (select distinct t1.playerid, t1.teamid, t1.yearid from (select playerid, teamid, yearid from pitching union select playerid, teamid, yearid from AllstarFull where GP = 1) t1), temp2(player1, player2, num_seasons) as (select t4.player1, t4.player2, count(t4.*) as num_seasons from (select DISTINCT t2.playerid as player1, t3.playerid as player2, t2.yearid from temp1 t2 join temp1 t3 on t2.playerid != t3.playerid and t2.teamid = t3.teamid and t2.yearid = t3.yearid) t4 group by t4.player1, t4.player2), rec_prereq(p1, p2, L, isCycle, path1) as (select player1, player2, num_seasons, false, ARRAY[player1 || '', player2 || '']::varchar[] from temp2 where player1 = 'webbbr01' union all select rec_prereq.p1, temp2.player2, rec_prereq.L + temp2.num_seasons, temp2.player2 = ANY(path1), (path1 || temp2.player2) from rec_prereq, temp2 where rec_prereq.p2 = temp2.player1 and rec_prereq.p2 != 'clemero02' and NOT isCycle) select EXISTS(select * from rec_prereq where p1 = 'webbbr01' and p2 = 'clemero02' and L >= 3 and isCycle = 'f') as pathexists;
