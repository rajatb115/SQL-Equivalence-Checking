create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE nodes AS ( SELECT DISTINCT playerid, teamid, yearid FROM pitching UNION SELECT DISTINCT playerid, teamid, yearid FROM allstarfull WHERE GP = 1 ), edges AS ( SELECT n1.playerid AS player1_id, n2.playerid AS player2_id, COUNT(*) AS weight FROM nodes n1 JOIN nodes n2 ON n1.playerid <> n2.playerid AND n1.teamid = n2.teamid AND n1.yearid = n2.yearid GROUP BY n1.playerid, n2.playerid ), paths AS ( SELECT 'webbbr01'::varchar AS player2_id, 0::bigint AS weight, ARRAY['webbbr01']::varchar[] AS path UNION ALL SELECT edges.player2_id, paths.weight + edges.weight, path || ARRAY[edges.player2_id]::varchar[] FROM paths, edges WHERE paths.player2_id = edges.player1_id AND edges.player2_id <> ALL(path) ) SELECT MAX(weight) >= 3 AS pathexists FROM paths WHERE player2_id = 'clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with RECURSIVE rec as ( select ARRAY[p1::text, p2::text] as paths, p2, edge_length as path_length from t2 where p1 = 'webbbr01' UNION ALL select rec.paths || sp.p2::text, sp.p2, rec.path_length + sp.edge_length from t2 as sp, rec where sp.p1 = rec.p2 and not sp.p2 = ANY (rec.paths) ), t1 as ( select playerID, yearID, teamID from Pitching UNION select playerID, yearID, teamID from AllstarFull where GP = 1 ), t2 as ( select temp1.playerID as p1, temp2.playerID as p2, count(*) as edge_length from t1 as temp1, t1 as temp2 where temp1.playerID <> temp2.playerID and temp1.yearID = temp2.yearID and temp1.teamID = temp2.teamID group by temp1.playerID, temp2.playerID ) select exists (select * from rec where 'clemero02' = ANY(paths) and path_length >= 3) as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
DROP TABLE IF EXISTS edges; CREATE TABLE edges ( playerID1 varchar(10) NOT NULL, playerID2 varchar(10) NOT NULL, edge_weight integer ); INSERT INTO edges WITH R AS ( SELECT DISTINCT playerID, teamid, yearid FROM pitching UNION SELECT playerID, teamid, yearid FROM allstarfull WHERE gp = 1 ) SELECT DISTINCT r1.playerID, r2.playerid, SUM(1) AS num FROM R AS r1 JOIN R AS r2 ON r1.teamID = r2.teamID AND r1.yearID = r2.yearID AND r1.playerID != r2.playerID GROUP BY r1.playerID, r2.playerID ; WITH RECURSIVE q AS ( SELECT ARRAY ['webbbr01'] AS arr, CAST('webbbr01' AS varchar(10)) UNION ALL SELECT CAST(q.arr AS varchar(10) []) || playerID2, playerID2 FROM q JOIN edges ON edges.playerID2 != ANY (q.arr) ) SELECT ( SELECT CASE WHEN EXISTS ( SELECT * FROM q WHERE 'clemero02' = ANY (q.arr) ) THEN TRUE ELSE FALSE END ) AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE VIEW Graph1 AS ( WITH Pdata (playerID, yearID, teamID, lgID) AS ( SELECT DISTINCT combine_data.* FROM (SELECT playerID, yearID, teamID, lgID FROM Pitching UNION ALL SELECT playerID,yearID,teamID,lgID  FROM AllstarFull WHERE GP = 1)  AS combine_data  ) , Wdata (player1,player2,weight) AS (SELECT  data1.playerID AS player1, data2.playerID AS player2, COUNT(DISTINCT(data2.yearID)) AS weight FROM Pdata AS data1 JOIN Pdata AS data2 ON data1.teamID = data2.teamID AND data1.yearID = data2.yearID  AND  data1.playerID != data2.playerID GROUP  BY player1 , player2) SELECT * FROM Wdata); WITH output AS ( WITH RECURSIVE pathway ( fro , too , path, weight ) AS ( SELECT bcase.player1 , bcase.player2 , ARRAY[bcase.player1::text , bcase.player2::text ], bcase.weight FROM Graph1 AS bcase WHERE bcase.player1 = 'webbbr01' UNION ALL SELECT pathway.fro , Graph1.player2 , pathway.path || ARRAY[ Graph1.player2::text], pathway.weight + Graph1.weight FROM pathway JOIN Graph1 ON pathway.too = Graph1.player1 AND Graph1.player2::text  != ALL(pathway.path) ) SELECT * FROM pathway WHERE pathway.too =  'clemero02' ) SELECT (CASE WHEN MAX(weight)>=3 THEN true ELSE false END) AS pathexists FROM output;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with var as (select p1,p2,count(yearID) as ew from (select var1.playerID as p1,var2.playerID as p2,var1.yearID,var1.teamID from ((select distinct playerID,yearID,teamID from Pitching) union (select playerID,yearID,teamID from AllstarFull where GP=1)) as var1, ((select distinct playerID,yearID,teamID from Pitching) union (select playerID,yearID,teamID from AllstarFull where GP=1)) as var2 where var1.playerID!=var2.playerID and var1.yearID=var2.yearID and var1.teamID=var2.teamID) as ft group by p1,p2 order by p1 , p2 ) , fvar as (select count(*) from ( with recursive fewt(p1,p2,few,pat,depth) as ( (select var.p1,var.p2,var.ew as few,array[var.p1] as pat,1 as depth from var where var.p1='webbbr01') union all ( select fewt.p1,var.p2,(fewt.few+var.ew) as few , (pat || var.p1)::varchar(10)[] as pat , (fewt.depth+1) as depth from fewt,var where fewt.p1='webbbr01' and fewt.p2=var.p1 and var.p2!=all(fewt.pat) and fewt.depth<3 )) select fewt.p1,fewt.p2,fewt.few from fewt where fewt.p2='clemero02' and fewt.few>=3 ) as ft1) select * from ((select true::bool as pathexists from fvar) union (select false::bool as pathexists)) as ghj order by pathexists desc limit 1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE VIEW Graph1 AS WITH P AS( SELECT * FROM (SELECT playerID, teamID, yearID FROM AllstarFull WHERE GP=1 GROUP BY playerID, teamID, yearID) AS S(playerID, teamID, yearID) UNION (SELECT playerID, teamID, yearID FROM Pitching GROUP BY playerID, teamID, yearID) ) SELECT P1.playerID AS player1_id, P2.playerID AS player2_id, COUNT(*) AS weight FROM P AS P1 JOIN P AS P2 ON (P1.playerID!=P2.playerID AND P1.teamID=P2.teamID AND P1.yearID=P2.yearID) GROUP BY P1.playerID, P2.playerID; WITH RECURSIVE P AS( SELECT player1_id, player2_id, weight, player1_id||'.'||player2_id AS walk FROM Graph1 WHERE player1_id='webbbr01' UNION SELECT P.player1_id, Graph1.player2_id, P.weight+Graph1.weight, P.walk||'.'||Graph1.player2_id FROM P JOIN Graph1 ON (P.player2_id=Graph1.player1_id AND P.walk NOT LIKE '%'||Graph1.player2_id||'%') ), R AS (SELECT * FROM P WHERE player2_id='clemero02') SELECT CASE WHEN EXISTS(SELECT weight FROM R) AND (SELECT MAX(weight) FROM R)>=3 THEN TRUE ELSE FALSE END AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive findpaths(paths, len, isvisited) as (select array[p1, p2],len,p1=p2 from edges where p1='webbbr01' union all select (paths || e.p2)::varchar(10)[],f.len + e.len,e.p2 = ANY(f.paths) from edges as e, findpaths as f where f.paths[array_length(paths, 1)] = e.p1 and not f.isvisited), edges as (select p1,p2,len from (select p1,p2,count(*) as len from(select t1.playerid as p1, t2.playerid as p2 from (select playerid,teamid,yearid from pitching union select playerid,teamid,yearid from allstarfull where gp=1) as t1,(select playerid,teamid,yearid from pitching union select playerid,teamid,yearid from allstarfull where gp=1) as t2 where t1.teamid=t2.teamid and t1.yearid = t2.yearid and t1.playerid!=t2.playerid) as t group by p1,p2) as m) select exists(select * from findpaths where paths[array_length(paths, 1)] = 'clemero02' and len>=3) as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive t as( select playerid, teamid, yearid from pitching union select playerid, teamid, yearid from allstarfull where gp = 1 ), s as( select t1.playerid as src, t2.playerid as dest, t1.yearid from t as t1, t as t2 where t1.teamid = t2.teamid and t1.playerid <> t2.playerid and t1.yearid = t2.yearid ), p as( select src, dest, count(yearid) as edge from s group by src, dest ), paths (src, dest, edge, path) as ( select src, dest, edge , array[src::text, dest::text] from p where src = 'webbbr01' union all select paths.src, p.dest, paths.edge + p.edge , (paths.path || p.dest::text) from paths join p on paths.dest = p.src and p.dest != all(paths.path) ) select case when edge >= 3 then 'True' when edge < 3 then 'False' end pathexists from paths where src = 'webbbr01' and dest = 'clemero02' limit 1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive rec(playerid1,playerid2,edge,n,is_cycle,path) as( select p1.playerid,p2.playerid,least(p1.g,p2.g),1,false,array[p2.playerid]::text[] from (select playerid,yearid,lgid,G,teamid from pitching union select playerid,yearid,lgid,gp,teamid from allstarfull) as p1, (select playerid,yearid,lgid,G,teamid from pitching union all select playerid,yearid,lgid,gp,teamid from allstarfull) as p2 where p1.playerid='webbbr01' and p1.teamid=p2.teamid and p2.playerid!='webbbr01' and p1.yearid=p2.yearid and p1.lgid=p2.lgid UNION ALL select rec.playerid1,p4.playerid,rec.edge+least(p3.g,p4.g),n+1,p4.playerid=any(path),path || p4.playerid::text FROM rec, (select playerid,yearid,lgid,G,teamid from pitching union select playerid,yearid,lgid,gp,teamid from allstarfull)as p3, (select playerid,yearid,lgid,G,teamid from pitching union select playerid,yearid,lgid,gp,teamid from allstarfull)as p4 where rec.playerid2=p3.playerid and p3.playerid!=p4.playerid and p4.playerid!=rec.playerid1 and p3.yearid=p4.yearid and p3.teamid=p4.teamid and p3.lgid=p4.lgid and n<3 and not is_cycle ) select max(edge) >=3 as pathexists from rec where playerid2='clemero02' group by playerid1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE g1n AS ( SELECT DISTINCT playerid, teamid, yearid FROM pitching UNION SELECT DISTINCT playerid, teamid, yearid FROM allstarfull WHERE GP = 1 ), g1e AS ( SELECT x.playerid AS player1_id, y.playerid AS player2_id, COUNT(*) AS w FROM g1n x JOIN g1n y ON x.teamid = y.teamid AND x.yearid = y.yearid AND x.playerid != y.playerid GROUP BY x.playerid, y.playerid ), paths AS ( SELECT player2_id AS tgt, w AS len, array[player1_id :: text, player2_id :: text] as stack FROM g1e WHERE player1_id = 'webbbr01' UNION ALL SELECT e.player2_id AS tgt, p.len + e.w AS len, stack || e.player2_id :: text AS stack FROM g1e e JOIN paths p ON p.tgt = e.player1_id AND e.player2_id <> ALL(stack) ), T AS ( SELECT * FROM paths WHERE tgt = 'clemero02' AND len >= 3 ) SELECT CASE WHEN EXISTS ( SELECT * FROM T ) THEN true::boolean ELSE false:: boolean END AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive all_paths (path_ids, length_path, visited) as ( with G1 as ( with G1_tmp as ( select distinct playerid, yearid, teamid from AllstarFull union select distinct playerid, yearid, teamid from Pitching ) select G1_tmp_1.playerid as player1_id, G1_tmp_2.playerid as player2_id, count(distinct G1_tmp_1.yearid) as edge_weight from G1_tmp as G1_tmp_1 join G1_tmp as G1_tmp_2 on G1_tmp_1.playerid != G1_tmp_2.playerid and G1_tmp_1.yearid = G1_tmp_2.yearid and G1_tmp_1.teamid = G1_tmp_2.teamid group by player1_id, player2_id ) select array[player1_id::text, player2_id::text], edge_weight, false::boolean from G1 where G1.player1_id = 'webbbr01' union all select (path_ids || player2_id::text), length_path + edge_weight, player2_id = any(path_ids) from G1 join all_paths on path_ids[array_length(path_ids, 1)] = player1_id and not visited ) select case when exists ( select * from all_paths where path_ids[array_length(path_ids, 1)] = 'clemero02' and length_path>=3 and visited is false ) then true::boolean else false::boolean end as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive all_players(playerid, teamid, yearid) as( SELECT DISTINCT playerid, teamid, yearid FROM pitching UNION SELECT DISTINCT playerid, teamid, yearid FROM AllstarFull where GP = 1 ), graph1(playerid1, playerid2, edge_weight) AS( SELECT a1.playerid as playerid1, a2.playerid as playerid2, COUNT(DISTINCT a1.yearid) AS edge_weight FROM all_players a1 JOIN all_players a2 ON a1.teamid = a2.teamid AND a1.yearid = a2.yearid AND a1.playerid <> a2.playerid GROUP BY 1, 2 ), shortest_paths(playerid1, playerid2, path_length) AS( SELECT graph1.playerid1, graph1.playerid2, graph1.edge_weight AS path_length FROM graph1 WHERE graph1.playerid1 = 'webbbr01' UNION SELECT sp.playerid1, graph1.playerid2, sp.path_length + graph1.edge_weight as path_length FROM shortest_paths sp JOIN graph1 ON sp.playerid2 = graph1.playerid1 AND graph1.playerid2 <> sp.playerid1 AND sp.path_length <=10 ) SELECT EXISTS( SELECT playerid1,playerid2 FROM shortest_paths WHERE playerid1 = 'webbbr01' AND playerid2 = 'clemero02' AND path_length >= 3 ) as pathexists ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive subt as (select playerid, yearID, teamid from pitching union select playerid, yearID, teamid from allstarfull where GP=1), teammate as (select p1.playerid as plyr1, p2.playerid as plyr2, p1.yearID from subt as p1, subt as p2 where p1.playerid<>p2.playerid and p1.teamid=p2.teamid and p1.yearID=p2.yearID), graph as (select plyr1, plyr2, count(distinct yearID) as wt from teammate group by plyr1, plyr2), rec as ( select wt, array['webbbr01', plyr2] as path from graph where plyr1='webbbr01' union all ( with t as (select rec.wt+graph.wt as wt, array_append(path, graph.plyr2) as path from graph, rec where path[array_upper(path, 1)]=graph.plyr1 and (not graph.plyr2=ANY(path))), t1 as (select count(*) from t where path[array_upper(path, 1)]='clemero02' and wt > 2) select wt, path from t, t1 where count=0 ) ), sq as (select rec.wt+graph.wt as wt, array_append(path, graph.plyr2) as path from graph, rec where path[array_upper(path, 1)]=graph.plyr1 and (not graph.plyr2=ANY(path))), sq1 as (select count(*) as c from sq where path[array_upper(path, 1)]='clemero02' and wt > 2) select (c>0) as pathexists from sq1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE uniData(player1_id,team_id,yearID) AS ( SELECT DISTINCT Pitching.playerID, Pitching.teamID, Pitching.yearID FROM Pitching UNION SELECT DISTINCT AllstarFull.playerID, AllstarFull.teamID, AllstarFull.yearID FROM AllstarFull ), edges(player1_id,player2_id,edgeWeight) AS ( SELECT DISTINCT u1.player1_id, u2.player1_id, COUNT(*) FROM uniData AS u1 JOIN uniData AS u2 ON u1.team_id = u2.team_id AND u1.yearID = u2.yearID WHERE u1.player1_id <> u2.player1_id GROUP BY u1.player1_id, u2.player1_id ), ptable(last_player, path,path_wt) AS ( SELECT e.player2_id,  ARRAY[e.player1_id] || e.player2_id, e.edgeWeight FROM edges e WHERE e.player1_id = 'webbbr01' UNION All SELECT  e.player2_id,  p.path|| e.player2_id, p.path_wt + e.edgeWeight FROM edges AS e, ptable p WHERE e.player1_id = p.last_player AND e.player2_id  <> ALL(p.path) AND e.player1_id <> 'clemero02' ), res_table AS ( SELECT path FROM ptable WHERE last_player = 'clemero02' AND path_wt >=3 LIMIT 1 ) SELECT exists (SELECT 1 FROM res_table) AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH graph1_edges AS ( WITH plM(playerID,teamID,yearID) as ( (SELECT playerID,teamID,yearID as games FROM pitching GROUP BY playerID,teamID,yearID) UNION ALL (SELECT playerID,teamID,yearID FROM allstarfull WHERE GP=1 GROUP BY playerID,teamID,yearID) ) SELECT t1.playerID as player1 ,t2.playerID as player2,count(*) as weight FROM plm t1 , plm t2 WHERE t1.teamID = t2.teamID AND t1.yearID=t2.yearID AND t1.playerID != t2.playerID GROUP BY t1.playerID,t2.playerID ) SELECT CASE WHEN EXISTS( WITH recursive path_rec AS (SELECT player2 as player,weight as len,Array[player1,player2]::Character varying(10)[] as pathh FROM graph1_edges WHERE player1='webbbr01' UNION ALL SELECT nxt.player2,prv.len+nxt.weight,array_append(prv.pathh,nxt.player2)::Character varying(10)[] FROM path_rec prv,graph1_edges nxt where prv.player = nxt.player1 AND  nxt.player2 !=ALL(prv.pathh) ) select * FROM path_rec where player = 'clemero02' AND len>=3) THEN TRUE ELSE FALSE END as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
create view graph1 as with t3 as (with t1 as ((select playerid , teamid , yearid from AllstarFull where gp=1) union (select playerid , teamid , yearid from pitching)) , t2 as ((select playerid , teamid , yearid from AllstarFull where gp=1) union (select playerid , teamid , yearid from pitching)) select t1.playerid as pid1 , t2.playerid as pid2 from t1 , t2 where t1.playerid != t2.playerid and t1.teamid = t2.teamid and t1.yearid = t2.yearid) select pid1 , pid2 , count(*) as weight from t3 group by pid1 , pid2; with t5 as (WITH RECURSIVE paths (src, dest, path, weight ) AS ( SELECT e.pid1, e.pid2, ARRAY[e.pid1::text, e.pid2::text], e.weight FROM graph1 e where e.pid1= 'webbbr01' UNION all SELECT p.src, e.pid2, p.path || ARRAY[e.pid2::text], p.weight+e.weight FROM paths p JOIN graph1 e ON p.dest = e.pid1 AND e.pid2::text != ALL(p.path) ) select distinct * from paths where paths.dest = 'clemero02') select case when max(weight) >= 3 then true else false end as pathexists from t5; drop view graph1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH GraphNodes AS (SELECT Pitching.playerID AS playerid, Pitching.teamID AS teamid, Pitching.yearID AS yearid FROM Pitching UNION SELECT AllStarFull.playerID AS playerid, AllStarFull.teamID AS teamid, AllStarFull.yearID AS yearid FROM AllStarFull WHERE AllStarFull.GP = 1), GraphEdges AS (WITH Temp AS (SELECT playerA.playerid as nodeA, playerB.playerid as nodeB, COUNT(DISTINCT(playerA.yearID)) AS edge_weight FROM GraphNodes playerA JOIN GraphNodes playerB ON playerA.playerID != playerB.playerID AND playerA.teamID = playerB.teamID AND playerA.yearID = playerB.yearID GROUP BY playerA.playerid, playerB.playerid) SELECT * FROM Temp), AllPaths AS (WITH RECURSIVE all_paths (start_node, end_node, path_arr, edge_weight) AS (SELECT Edge.nodeA, Edge.nodeB, ARRAY[Edge.nodeB::text, Edge.nodeB::text], Edge.edge_weight FROM GraphEdges Edge WHERE Edge.nodeA = 'webbbr01' UNION ALL SELECT all_paths.start_node, GraphEdges.nodeB, all_paths.path_arr || ARRAY[GraphEdges.nodeB::text], all_paths.edge_weight + GraphEdges.edge_weight FROM all_paths JOIN GraphEdges ON all_paths.end_node = GraphEdges.nodeA AND GraphEdges.nodeB::text != ALL(all_paths.path_arr)) SELECT * FROM all_paths WHERE all_paths.end_node = 'clemero02')  SELECT CASE WHEN MAX(edge_weight) >= 3 THEN TRUE ELSE FALSE END AS pathexists FROM AllPaths;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive  same_team(playerID,teamID,yearID) as ( ( select playerID,teamID,yearID from Pitching ) union ( select playerID,teamID,yearID from AllstarFull where GP=1 ) ), edges(playerID1,playerID2,edgewt) as ( select p1.playerID,p2.playerID,least(count(distinct p1.yearID),3) from same_team p1 ,same_team p2 where p1.teamID=p2.teamID and p1.yearID=p2.yearID and p1.playerID!=p2.playerID group by p1.playerID,p2.playerID ), graph1(playerID1,playerID2,edgewt) as ( select playerID1,playerID2,edgewt from edges where playerID1='webbbr01' union select g1.playerID1 as playerID1,ed.playerID2 as playerID2,least((g1.edgewt+ed.edgewt),3) as edgewt from graph1 g1,edges ed where g1.playerID2=ed.playerID1 ) select coalesce(max(edgewt),0)>=3 as pathexists from graph1 where playerID1='webbbr01' and playerID2='clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive node_edge(playerid, teamid, yearid) AS ( SELECT DISTINCT playerid, teamid, yearid FROM pitching UNION SELECT DISTINCT playerid, teamid, yearid FROM allstarfull ), node_edge2(playerid1, playerid2, teamid, yearid) AS ( SELECT DISTINCT a.playerid as playerid1, b.playerid as playerid2, a.teamid, a.yearid FROM node_edge a JOIN node_edge b ON a.playerid <> b.playerid and a.teamid = b.teamid and a.yearid = b.yearid ), edges(playerid1, playerid2, weight) AS ( SELECT DISTINCT playerid1, playerid2, COUNT(*) as weight FROM node_edge2 GROUP BY playerid1, playerid2 ORDER BY playerid1, playerid2 ), search_graph(start_node , curr_node , depth, path1) AS ( SELECT edges.playerid1::varchar , edges.playerid2::varchar , edges.weight , ARRAY[edges.playerid1 || '']::varchar[] FROM edges WHERE edges.playerid1 = 'webbbr01' UNION ALL SELECT edges.playerid1::varchar, edges.playerid2::varchar, depth + edges.weight , (path1 || edges.playerid1)::varchar[] FROM search_graph sg JOIN edges ON sg.curr_node = edges.playerid1 AND edges.playerid2 <> ALL(path1) AND sg.start_node <> 'clemero02' ), ans(playerid) as ( SELECT DISTINCT curr_node FROM search_graph WHERE curr_node = 'clemero02' and depth >=3 ), ans2(cnt) as (SELECT COUNT(*) FROM ans) SELECT (CASE WHEN cnt = 1 THEN TRUE ELSE FALSE END) AS pathexists FROM ans2;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE Paths (src, dest, depth, length, path) AS ( (SELECT src, dest, 1, wt, ARRAY[src, dest] FROM Edges WHERE src = 'webbbr01') UNION ALL (SELECT p.src, e.dest, p.depth + 1, p.length + e.wt, (p.path || e.dest)::VARCHAR(10)[] FROM Paths p, Edges e WHERE p.dest = e.src AND NOT (e.dest = ANY(p.path)) ) ), Nodes AS (SELECT playerid, yearid, teamid FROM AllstarFull UNION SELECT playerid, yearid, teamid FROM Pitching), Edges AS (SELECT a.playerid AS src, b.playerid AS dest, COUNT(a.yearid) AS wt FROM Nodes a, Nodes b WHERE a.yearid = b.yearid AND a.teamid = b.teamid AND a.playerid != b.playerid GROUP BY a.playerid, b.playerid) SELECT EXISTS (SELECT 1 FROM Paths p WHERE p.dest = 'clemero02' AND p.length >= 3) AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive table1 as( select distinct playerid, teamid, yearid from pitching union select distinct playerid, teamid, yearid from allstarfull ), graph1 as( select p1.playerID as player1, p2.playerID as player2, count(*) as weight from table1 p1, table1 p2 where p1.yearID = p2.yearID and p1.teamID = p2.teamID and p1.playerid != p2.playerid group by player1, player2 ), table0(player,dist,visited) as ( select player2 as player, weight as dist, array[player2::text] as visited from graph1 where graph1.player1 = 'webbbr01' union all select t1.player2 as player, (t2.dist + t1.weight) as dist, t2.visited || t1.player2::text as visited from graph1 t1, table0 t2 where t2.player = t1.player1 and t1.player2 <> 'webbbr01' and t1.player2<>ALL(visited) ) select case when 'clemero02' in (select player from table0 where dist>=3 and player = 'clemero02' limit 1) then True else False end as pathexists; drop view graph1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive a as ( select distinct playerid, yearid, teamid from pitching union ( select distinct playerid, yearid, teamid from allstarfull where gp = 1 ) ), b as ( select a1.playerid as p1_id, a2.playerid as p2_id, a1.teamid, a1.yearid from a a1 join a a2 on a1.teamid = a2.teamid and a1.yearid = a2.yearid and a1.playerid != a2.playerid ), nodes as ( select distinct playerid from a ), edges as ( select p1_id, p2_id, count(*) as cnt from b group by p1_id, p2_id having count(*) > 0 order by p1_id, p2_id ), cte as ( select distinct p2_id as next, ARRAY [p1_id] :: varchar(10) [] as vis, cnt as len, 1 as depth from edges where p1_id = 'webbbr01' union all select distinct p2_id, (vis || p1_id) :: varchar(10) [], (cnt + len), depth + 1 from edges, cte where cte.next = edges.p1_id and not (edges.p2_id = any (vis)) and not ( cte.next = 'clemero02' and (len) >= 3 ) ) select True as pathexists from cte where cte.next = 'clemero02' and cte.len >= 3 group by cte.next having count(*) >= 1 union select False as pathexists from cte where cte.next = 'clemero02' and cte.len >= 3 group by cte.next having count(*) = 0;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive nodes1 as( SELECT DISTINCT Pitching.playerID FROM Pitching UNION SELECT DISTINCT AllstarFull.playerID FROM AllstarFull WHERE AllstarFull.GP = 1 ), info as( SELECT nodes1.playerID, teamID, yearID FROM nodes1 JOIN AllstarFull ON nodes1.playerID = AllstarFull.playerID UNION SELECT nodes1.playerID, teamID, yearID FROM nodes1 JOIN Pitching ON nodes1.playerID = Pitching.playerID ), edges as( SELECT a.playerID as player_1, b.playerID as player_2, COUNT(*) as num_seasons FROM info a JOIN info b ON a.teamID = b.teamID AND a.yearID = b.yearID AND a.playerID <> b.playerID GROUP BY a.playerID, b.playerID ), graph1 as ( SELECT nodes1.playerID as player_1, edges.player_2 as player_2, num_seasons as num_seasons FROM nodes1 LEFT JOIN edges ON nodes1.playerID = edges.player_1 ), rec_prepreq as( SELECT player_1, player_2, 1 as length_, 'f'::bool as Cycle, ARRAY[player_1 || '', player_2 || '']::varchar[] as path_ FROM graph1 WHERE player_1 = 'webbbr01' UNION ALL SELECT rec_prepreq.player_1, graph1.player_2, rec_prepreq.length_+1, graph1.player_2 = ANY(path_), path_||graph1.player_2 FROM rec_prepreq, graph1 WHERE rec_prepreq.player_2 = graph1.player_1 AND NOT Cycle AND rec_prepreq.player_2 <> 'clemero02' ) SELECT EXISTS( SELECT * FROM rec_prepreq WHERE player_1 = 'webbbr01' AND player_2 = 'clemero02' AND length_  >= 3 AND Cycle = 'f' ) as pathexists ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE merge_table(playerID, yearID, teamID) AS ( SELECT DISTINCT playerID, yearID, teamID FROM Pitching UNION SELECT DISTINCT playerID, yearID, teamID FROM AllstarFull WHERE GP = 1 ), main_table(player1, player2, num_matches) as ( SELECT p1.playerID, p2.playerID, COUNT(*) FROM merge_table as p1 JOIN merge_table as p2 ON p1.teamID = p2.teamID AND p1.yearID = p2.yearID AND p1.playerID != p2.playerID GROUP BY p1.playerID, p2.playerID ), graph1(player1, player2, path, length) AS ( SELECT f.player1, f.player2, array[f.player1 || '', f.player2] :: varchar[], f.num_matches FROM main_table as f WHERE f.player1 = 'webbbr01' UNION ALL SELECT g.player1, f.player2, g.path || array[f.player2] :: varchar[], g.length + f.num_matches FROM main_table as f JOIN graph1 as g ON f.player1 = g.player2 AND f.player2 != ALL(g.path) ), res(path) AS ( SELECT path FROM graph1 WHERE player2 = 'clemero02' AND length >= 3 LIMIT 1 ) SELECT exists (SELECT 1 FROM res) AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive allPlayers as ( select distinct playerid, teamid, yearid from ( select playerid, teamid, yearid from pitching union select playerid, teamid, yearid from allstarfull where gp = 1 ) as temp ), edge(player1id, player2id, edgeWeight) as ( select p1.playerid, p2.playerid, least(count(distinct p1.yearid), 3) from allPlayers as p1 join allPlayers as p2 on p1.playerid <> p2.playerid and p1.teamid = p2.teamid and p1.yearid = p2.yearid group by p1.playerid, p2.playerid ), rec(player1id, player2id, weight) as ( select player1id, player2id, edgeWeight from edge where player1id = 'webbbr01' union distinct select rec.player1id, edge.player2id, least(rec.weight + edge.edgeWeight, 3) from edge join rec on rec.player1id <> edge.player2id and rec.player2id = edge.player1id ) select ( select max(weight) from rec ) = 3 as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE t1 AS( SELECT DISTINCT playerid, teamid, yearid FROM ( SELECT playerid, teamid, yearid FROM pitching UNION SELECT playerid, teamid, yearid FROM AllstarFull where GP=1 )AS u ), paths AS ( SELECT DISTINCT a1.playerid AS node1, a2.playerid AS node2, count(a1.yearid) AS w FROM t1 a1 JOIN t1 a2 ON a1.teamid=a2.teamid AND a1.yearid=a2.yearid AND a1.playerid!=a2.playerid GROUP BY node1, node2 ORDER BY node1 ), finalpath (node, len, path) AS ( SELECT p.node2, p.w, ARRAY[p.node1::text]::text[] FROM paths p WHERE p.node1='webbbr01' UNION ALL SELECT p.node2, fp.len+p.w, array_append(fp.path,p.node1::text) FROM finalpath fp JOIN paths p ON fp.node=p.node1 AND p.node2 != ALL(fp.path) ), t2 AS (SELECT MAX(len) FROM (SELECT len FROM finalpath WHERE node='clemero02' UNION SELECT 0 AS "len") AS u) SELECT CASE WHEN max>=3 THEN TRUE ELSE FALSE END AS pathexists FROM t2;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE VIEW v1 AS SELECT playerID,yearID,teamID FROM Pitching UNION SELECT playerID,yearID,teamID FROM AllstarFull WHERE GP = 1; CREATE VIEW Graph1 AS SELECT t1.playerID AS player1,t2.playerID AS player2,COUNT(*) AS weight FROM v1 t1,v1 t2 WHERE t1.teamID = t2.teamID AND t1.yearID = t2.yearID AND t1.playerID != t2.playerID GROUP BY player1,player2; with recursive rec_path(src,dest,path,length) as( SELECT player1,player2,ARRAY[player1,player2] ::varchar(10)[],weight FROM Graph1 UNION ALL SELECT rec_path.src,Graph1.player2,(rec_path.path || ARRAY[Graph1.player2]) ::varchar(10)[],rec_path.length+Graph1.weight FROM rec_path JOIN Graph1 ON rec_path.dest = Graph1.player1 AND Graph1.player2 != ALL(rec_path.path) ) SELECT CASE WHEN EXISTS(SELECT * FROM rec_path WHERE src = 'webbbr01' AND dest = 'clemero02' AND length >=3) THEN 'True' ELSE 'False' END AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with temp_table(playerid,teamid,yearid) as (select playerid,teamid,yearid from Pitching union select playerid,teamid,yearid from AllstarFull where GP=1), merged_table(player1,player2,teamid,yearid) as (select temp1.playerid,temp2.playerid,temp1.teamid,temp1.yearid from temp_table as temp1 join temp_table as temp2 on temp1.teamid = temp2.teamid and temp1.yearid = temp2.yearid where temp1.playerid != temp2.playerid), graph1(player1,player2,weight) as (select distinct player1,player2,count(*) from merged_table group by player1,player2) select exists ( with recursive aux_graph(player1,player2,length,visited) as (select g1.player1::varchar,g1.player2::varchar,g1.weight,array[g1.player1||'',g1.player2||'']::varchar[] from graph1 g1 where g1.player1 = 'webbbr01' union all select aux_g.player1::varchar,g1.player2::varchar,aux_g.length+g1.weight,(aux_g.visited || g1.player2)::varchar[] from aux_graph aux_g,graph1 g1 where g1.player1 = aux_g.player2 and g1.player2 != all(aux_g.visited)) select 1 from aux_graph where player2 = 'clemero02' and length>=3 ) as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive abc as ( select distinct playerid as nodes from allstarfull where gp > 0 union (select distinct playerid from pitching)), graph1 as ( select a1.nodes as node1, a2.nodes as node2, count(*) as weight from abc as a1, abc as a2, appearances as ap1, appearances as ap2 where a1.nodes <> a2.nodes and ap1.playerid = a1.nodes and  ap2.playerid = a2.nodes and ap1.teamid = ap2.teamid and ap1.yearid = ap2.yearid and ap1.lgid = ap2.lgid group by a1.nodes, a2.nodes), graph_rec(node, pathh, p_len) as ( select node2 as node, array[node1, node2]::varchar(10)[] as pathh, weight from graph1 where node1 = 'webbbr01' union all select node2, array_append(prev.pathh, node2)::varchar(10)[], p_len + next.weight from graph_rec prev, graph1 next where next.node1 = prev.node and next.node2 != ALL(prev.pathh)), exist as ( select * from graph_rec where node = 'clemero02' and p_len >= 3 limit 1) select (case when p_len >= 3 then true else false end) as pathexists from exist;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
SELECT CASE WHEN COUNT(*)=0 OR MAX(length)<3 THEN FALSE ELSE TRUE END AS pathexists FROM (WITH RECURSIVE edges AS (SELECT t1.playerid AS first_playerid, t2.playerid AS second_playerid, COUNT(*) AS weight FROM Appearances t1 JOIN Appearances t2 ON t1.playerid!=t2.playerid AND t1.teamid=t2.teamid AND t1.yearid=t2.yearid WHERE t1.playerid IN ((SELECT DISTINCT playerid FROM Pitching) UNION (SELECT DISTINCT playerid FROM AllStarFull WHERE GP = 1)) AND t2.playerid IN ((SELECT DISTINCT playerid FROM Pitching) UNION (SELECT DISTINCT playerid FROM AllStarFull WHERE GP = 1)) GROUP BY t1.playerid, t2.playerid), paths (first_playerid, last_playerid, path, length) AS (SELECT first_playerid, second_playerid, ARRAY[first_playerid,second_playerid], weight FROM edges WHERE first_playerid = 'webbbr01' UNION ALL SELECT paths.first_playerid, edges.second_playerid, CAST(paths.path||ARRAY[edges.second_playerid] AS varchar(10)[]), paths.length+edges.weight FROM paths JOIN edges ON paths.last_playerid = edges.first_playerid AND edges.second_playerid != ALL(paths.path) WHERE 'clemero02' != ALL(paths.path) AND paths.length<3) SELECT * FROM paths WHERE last_playerid = 'clemero02') AS t1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive distance as (select array[playerid1::text, playerid2::text] as undir_path, playerid2 as playerid, weight as length from graph1 where playerid1 = 'webbbr01' union all select distance.undir_path || playerid2::text, playerid2, length + weight from graph1, distance where graph1.playerid1 = distance.playerid and not graph1.playerid2 = any(distance.undir_path)), t(playerid, yearid, teamid) as (select distinct playerid, yearid, teamid from pitching union select distinct playerid, yearid, teamid from allstarfull where GP = 1), t1(playerid1, playerid2, yearid, teamid) as (select x.playerid, y.playerid, x.yearid, x.teamid from t as x join t as y on x.yearid = y.yearid and x.teamid = y.teamid and x.playerid != y.playerid), graph1(playerid1, playerid2, weight) as (select playerid1, playerid2, count(yearid) from t1 group by playerid1, playerid2) select exists(select * from distance where 'clemero02' = any(distance.undir_path) and distance.length >= 3) as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE Connected(playerid1 ,playerid2,length,weight,route,cycle) AS ( SELECT S.playerid1,S.playerid2, CAST(0 AS bigint),S.weight, ARRAY[S.playerid1::text],false FROM Graph as S WHERE S.playerid1 = 'webbbr01' UNION ALL SELECT S.playerid1,S.playerid2 ,C.weight + length, S.weight, route || (S.playerid1::text), S.playerid1 = ANY(route) FROM Graph as S, Connected as C WHERE S.playerid1 = C.playerid2 AND NOT cycle ), Valid_People(playerid,yearID,teamid) AS ( SELECT DISTINCT playerid ,yearID ,teamid FROM( (SELECT playerid,yearID,teamid FROM Pitching) UNION (SELECT playerid,yearID,teamid FROM AllstarFull WHERE GP = 1) ) AS T ), Edges(playerid1,playerid2,teamid,yearID) AS ( SELECT V1.playerid as  playerid1,V2.playerid as playerid2,V1.teamid as teamid, V1.yearID as yearID FROM Valid_People as V1 JOIN Valid_People as V2 ON (V1.teamid = V2.teamid AND V1.yearID = V2.yearID) WHERE V1.playerid <> V2.playerid ), Graph(playerid1,playerid2,weight) AS ( SELECT playerid1,playerid2,weight FROM ( ( SELECT playerid1,playerid2, COUNT(*) AS weight FROM Edges GROUP BY playerid1,playerid2 ) UNION ( SELECT playerid2,playerid1, COUNT(*) AS weight FROM Edges GROUP BY playerid1,playerid2 ) ) AS T ) SELECT CASE WHEN EXISTS( select playerid2 FROM Connected WHERE playerid2 = 'clemero02' AND length>=3) THEN TRUE ELSE FALSE END as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with z as (select playerid from pitching union (select playerid from allstarfull where gp=1)),w as(select appearances.playerid,appearances.yearid,appearances.teamid from appearances inner join z on z.playerid=appearances.playerid) ,k as (select a.playerid as node1,a.yearid,a.teamid,b.playerid as node2 from w as a inner join w as b on a.teamid=b.teamid and a.yearid=b.yearid   ) , s as (select node1,node2,count(*) as num_seasons from k group by node1 ,node2) ,d as (select node1,node2,num_seasons from s where node1!=node2) select * from d;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive lim_stars as ( select * from AllstarFull where gp = 1 ), nodes as ( (select playerid, teamid, yearid from lim_stars) union (select playerid, teamid, yearid from pitching) ), list as ( select n1.playerid as player1, n2.playerid as player2, n1.teamid, n1.yearid from nodes n1, nodes n2 where n1.playerid != n2.playerid and n1.teamid = n2.teamid and n1.yearid = n2.yearid ), adj_list as ( select player1, player2, count(yearid) as num from list group by player1, player2 ), res1 as ( select count(*) from adj_list where player1 = 'webbbr01' and player2 = 'clemero02' and num >= 3 ), res2 as ( select count(*) from adj_list adj1, adj_list adj2 where adj1.player1 = 'webbbr01' and adj1.player2 = adj2.player1 and adj2.player2 = 'clemero02' and ( adj1.num >= 2 or adj2.num >= 2 ) ), A as ( select player2 as player, num from adj_list where player1 = 'webbbr01' ), B as ( select player1 as player, num from adj_list where player2 = 'clemero02' ), search as ( select player from adj_list, A where adj_list.player2 = A.player union select player2 from adj_list, search where adj_list.player1 = search.player ), res3 as ( select count(*) from ( select player from search intersect select player from B ) as t ), res as ( select * from res1 union select * from res2 union select * from res3 ) select count(*) > 0 as pathexists from res;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE t1 AS (SELECT playerID, yearID, teamID FROM AllstarFull WHERE GP = 1), t2 AS (SELECT playerID, yearID, teamID FROM Pitching), t3 AS (SELECT * FROM t1 UNION SELECT * FROM t2), t4 AS (SELECT A.playerID AS p1 , A.yearID AS y, A.teamID AS tID, B.playerID AS p2 FROM t3 A, t3 B WHERE A.yearID = B.yearID AND A.teamID = B.teamID AND A.playerID != B.playerID ), t5 AS (SELECT DISTINCT t4.p1, t4.p2, t4.y FROM t4), t6 AS (SELECT t5.p1, t5.p2, COUNT(t5.y) AS wgt FROM t5 GROUP BY t5.p1, t5.p2 ORDER BY t5.p1, t5.p2), t7 AS ( SELECT array['webbbr01', t6.p2] AS arr , t6.wgt AS wgt FROM t6 WHERE t6.p1='webbbr01' UNION ALL ( WITH t7_copy as (table t7), t AS (SELECT COUNT(*) FROM t7_copy WHERE  arr[array_upper(arr, 1)] = 'clemero02' AND t7_copy.wgt >= 3) SELECT array_append(arr, t6.p2) AS arr, t6.wgt+t7_copy.wgt AS wgt  FROM t6, t7_copy , t WHERE t.COUNT = 0 AND t6.p1 = arr[array_upper(arr, 1)] AND (NOT t6.p2 = ANY(arr)) ) ), t8 AS (SELECT CASE WHEN (t7.arr[array_upper(t7.arr, 1)] = 'clemero02' AND t7.wgt >= 3) THEN True ELSE False END AS pathexists FROM t7 ORDER by pathexists DESC) SELECT  * FROM t8 limit 1;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE node1 AS( SELECT pitching.playerid, allstarfull.teamid, allstarfull.yearid FROM pitching JOIN allstarfull ON (pitching.playerid=allstarfull.playerid AND gp=1)), node2 AS( SELECT pitching.playerid, allstarfull.teamid, allstarfull.yearid FROM pitching JOIN allstarfull ON (pitching.playerid=allstarfull.playerid AND gp=1)), weights AS ( SELECT node1.playerid AS player1, node2.playerid AS player2, CASE WHEN (node1.playerid=node2.playerid) THEN 0 ELSE COUNT(DISTINCT(node2.yearid)) END AS weight FROM node1 JOIN node2 ON (node1.yearid=node2.yearid AND node1.teamid=node2.teamid) GROUP BY node1.playerid,node2.playerid ), paths(player1,player2,length,is_cycle,path) AS( SELECT player1,player2,weight AS length, false AS is_cycle,ARRAY[weights.player2::text] AS path FROM weights WHERE player1=weights.player1 AND player2=weights.player2 UNION ALL SELECT weights.player1,weights.player2,paths.length+weights.weight AS length, weights.player2=ANY(path) AS is_cycle, paths.path||weights.player2::text AS path FROM paths JOIN weights ON paths.player1=weights.player2 AND NOT is_cycle) SELECT CASE WHEN (length>=3) THEN 'true' ELSE 'false' END AS pathexists FROM paths WHERE player1='webbbr01' AND player2='clemer01';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE dfs(str, endd, pathh, pathlen, arrlen) AS ( ( SELECT CAST('' AS varchar(10)), CAST('webbbr01' AS varchar(10)), ARRAY['webbbr01'], CAST(0 AS bigint), 1 ) UNION ALL ( SELECT dfs.endd, g1.pid2, CAST(pathh AS varchar(10)[]) || g1.pid2  , pathlen + g1.wt, arrlen + 1 FROM dfs, g1 WHERE dfs.endd = g1.pid1 AND g1.pid2 != ANY(pathh) ) ), t1 AS ( ( SELECT DISTINCT playerid, teamid, yearid AS seasonid FROM pitching ) UNION ( SELECT DISTINCT playerid, teamid, yearid AS seasonid FROM allstarfull WHERE gp=1 ) ), t2 AS ( SELECT p1.playerid AS pid1, p2.playerid AS pid2, p1.teamid AS tid, p1.seasonid AS sid FROM t1 AS p1, t1 AS p2 WHERE p1.playerid != p2.playerid AND (p1.teamid, p1.seasonid) = (p2.teamid, p2.seasonid) ORDER BY pid1, pid2 ), g1 AS ( SELECT pid1, pid2, COUNT(*) AS wt FROM t2 GROUP BY pid1, pid2 ORDER BY wt DESC, pid1, pid2 ) SELECT ( CASE WHEN pathlen IS NOT NULL THEN TRUE ELSE FALSE END ) AS pathexists FROM ( SELECT pathlen FROM dfs WHERE pathh[arrlen] = 'clemero02' AND pathlen>=3 LIMIT 1 ) AS something;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive temp1(p1, y1, t1) AS ( SELECT playerID, yearID , teamID FROM Pitching ), temp2(p2, y2 ,t2) AS ( SELECT playerID, yearID , teamID from AllstarFull where GP is not null and GP = 1 ), temp3(p3,y3,t3) as ( SELECT DISTINCT * from temp1 UNION SELECT DISTINCT * from temp2 ), temp4 (p1, p2 , t , y) as ( SELECT A.p3 , B.p3 , A.t3, A.y3 from temp3 A , temp3 B where A.p3 != B.p3 AND A.t3 = B.t3 and A.y3 = B.y3 ), temp5 (p1 , p2 , w) as ( SELECT p1 , p2 , least(COUNT(DISTINCT y) , 3) FROM temp4 GROUP by p1 , p2 ), search_path(n1 , n2 , wt) AS ( SELECT p1 , p2 , w from temp5 where p1 = 'webbbr01' union SELECT search_path.n1 as p1 , temp5.p2 as p2 , least ((search_path.wt + temp5.w) , 3) as w from search_path , temp5 where search_path.n2 = temp5.p1 ), temp6 (num_path) as ( SELECT COUNT(*) from search_path where n2 = 'clemero02' and wt >= 3 ) SELECT case when num_path > 0 then True else False end as pathexists from temp6  ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with Graph1 as ( with Player_tb(playerID,teamID,yearID) as ((select distinct playerID,teamID,yearID as games from pitching) UNION ALL (select distinct playerID,teamID,yearID as games from allstarfull where GP =1 )) select A.playerid as player1,B.playerid as player2, count(*) as weight from Player_tb A , Player_tb B where A.teamID = B.teamID and A.yearID =B.yearID and A.playerID != B.playerID group by A.playerID,B.playerid) select case when exists(with recursive rec_path(Path_len,player,Path) as (select weight,player2, Array[player1,player2]:: Character varying(10)[] from Graph1 where player1 = 'webbbr01' UNION ALL select P1.Path_len+P2.weight,P2.player2,Array_append(P1.Path,P2.player2)::Character varying(10)[] from rec_path P1,Graph1 P2 where P2.player2 != All(P1.Path)  and  P1.player =P2.player1 )   select * from rec_path where player = 'clemero02' and Path_len >=3) then TRUE else FALSE end as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive bfs(dest,w,nodesinpath) AS( SELECT graph.node2 as dest, w , ARRAY['webbbr01']::character varying[] FROM  graph WHERE graph.node1='webbbr01' UNION ALL select graph.node2 , bfs.w+graph.w,nodesinpath||graph.node1 FROM bfs,graph WHERE bfs.dest=graph.node1 AND graph.node2 <> ANY(bfs.nodesinpath)  AND bfs.dest <> 'clemero02' ) , newt as (select  playerid, yearid, teamid from allstarfull union select playerid ,yearid, teamid from pitching ) , graph as (select n1.playerid as node1, n2.playerid as node2 ,count(*)as w FROM  newt as n1, newt as n2 WHERE n1.yearid=n2.yearid and n1.teamid  = n2.teamid and n1.playerid<>n2.playerid GROUP BY node1,node2) select case when maxpath > 2 then true else false end as pathexists from (select max(w) as maxpath from bfs where dest ='clemero02') as ml ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE t as( SELECT playerid::varchar,teamid,yearid From Pitching p UNION SELECT playerid::varchar,teamid,yearid From Allstarfull a WHERE a.GP=1 ) ,graph1 AS( SELECT t.playerid as player1_id,t2.playerid as player2_id,COUNT(*) as eweight FROM t,t t2 WHERE t.playerid!=t2.playerid AND t.teamid=t2.teamid AND t.yearid=t2.yearid GROUP BY t.playerid,t2.playerid ), pairs(player1_id,player2_id,eweight,is_cycle,hop,path) AS( SELECT g.player1_id as player1_id,g.player2_id as player2_id,g.eweight,false,0 AS hop,ARRAY[player1_id,player2_id] FROM graph1 g WHERE g.player1_id='webbbr01' UNION SELECT pairs.player1_id, g.player2_id, pairs.eweight+g.eweight AS eweight,g.player2_id=ANY(path),hop+1 AS hop,(path || g.player2_id) FROM pairs, graph1 g WHERE g.player1_id=pairs.player2_id AND pairs.player1_id!=g.player2_id AND NOT is_cycle ), t1 AS( SELECT player2_id,MAX(hop) as max_hop FROM pairs GROUP BY player2_id ), t2 as( SELECT player2_id,max_hop FROM t1 WHERE player2_id='clemero02' ) SELECT (CASE WHEN t2.max_hop>=3 THEN TRUE ELSE FALSE END) as pathexists FROM t2;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive gra as (select distinct playerid,teamid,yearid from pitching union select distinct playerid,teamid,yearid from allstarfull where gp=1),graph1 as(select g1.playerid as src ,g2.playerid as dst ,count(distinct(g1.yearid)) as weight from gra as g1,gra as g2 where g1.teamid=g2.teamid and g1.playerid!=g2.playerid and g1.yearid=g2.yearid group by g1.playerid,g2.playerid),finalG(src,dst,weight,path) as ( select distinct src,dst,weight,ARRAY[src::text, dst::text] from graph1 where src='webbbr01' union all select distinct g.src,g.dst,p.weight+g.weight,p.path || ARRAY[g.dst::text] from finalG as p,graph1 as g where p.dst=g.src and g.dst!=p.src AND g.dst::text != ALL(p.path)) select case when max(weight)>=3 then true else false end as pathexists from finalG as f where f.dst='clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
create view edges as select p1 as src, p2 as dest , count(*) as weight from (select distinct x.playerid as p1, y.playerid as p2, x.teamid from ((select playerid, teamid, yearid from pitching) union (select playerid, teamid, yearid from allstarfull where gp=1)) as x, ((select playerid, teamid, yearid from pitching) union (select playerid, teamid, yearid from allstarfull where gp=1)) as y where x.teamid = y.teamid and x.yearid = y.yearid and x.playerid != y.playerid) as t group by p1, p2; with recursive paths(src, dest, path, pathlength) AS ( SELECT e.src, e.dest, ARRAY[e.src::text, e.dest::text], e.weight FROM edges e WHERE e.src = 'webbbr01' UNION all SELECT p.src, e.dest, p.path || ARRAY[e.dest::text], p.pathlength+e.weight FROM paths p JOIN edges e ON p.dest = e.src AND e.dest::text != ALL(p.path)) select case when max(pathlength)>=3 then true else false end as pathexists from paths where dest = 'clemero02';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE TEMPORARY TABLE graph_data(player1 VARCHAR(255),player2 VARCHAR(255),weight int); INSERT INTO graph_data(player1,player2,weight) WITH filter(player) AS (SELECT playerID FROM pitching UNION SELECT playerID FROM allstarfull WHERE GP=1), data(player,team,year) AS (SELECT player,teamID,yearID FROM filter,appearances WHERE player=playerID) SELECT p1.player,p2.player,COUNT(*) AS c FROM data AS p1,data AS p2 WHERE p1.team=p2.team AND p1.year=p2.Year AND p1.player<>p2.player GROUP BY p1.player,p2.player ORDER BY c DESC; WITH RECURSIVE paths(start_node,end_node,path,length) AS ( SELECT player1,player2,player1||','||player2||',',weight FROM graph_data WHERE player1 = 'webbbr01' UNION SELECT paths.start_node,graph_data.player2,paths.path || graph_data.player2 ||',',paths.length+graph_data.weight FROM paths JOIN graph_data ON paths.end_node = graph_data.player1 AND position(graph_data.player2||',' IN paths.path) = 0 ),temp(start,final,route) AS (SELECT * FROM paths WHERE end_node = 'clemero02' AND length>=3 LIMIT 1) SELECT CASE WHEN COUNT(*)>=1 THEN True ELSE False END AS pathexists; DROP TABLE graph_data;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE graph_paths AS ( SELECT startPath, endPath, length, ARRAY [startPath::text] as visited FROM ( SELECT a.playerID as startPath, b.playerID as endPath, COUNT(a.yearID) as length FROM allstarfull a JOIN allstarfull b ON a.teamID = b.teamID AND a.yearID = b.yearID WHERE a.playerID != b.playerID GROUP BY a.playerID, b.playerID ) AS graph WHERE startPath = 'webbbr01' or startPath = 'clemero02' UNION ALL SELECT p.startPath, c.endPath, p.length + c.length, p.visited || c.endPath :: text FROM graph_paths p JOIN ( SELECT a.playerID as startPath, b.playerID as endPath, COUNT(a.yearID) as length FROM allstarfull a JOIN allstarfull b ON a.teamID = b.teamID AND a.yearID = b.yearID WHERE a.playerID != b.playerID GROUP BY a.playerID, b.playerID ) as c ON c.startPath = p.endPath WHERE p.length < 6 AND NOT (c.endPath = ANY(p.visited)) ) SELECT CASE WHEN COUNT(*) > 0 then True ELSE False END AS pathexists FROM graph_paths WHERE length >= 3 and ( startPath = 'webbbr01' and endPath = 'clemero02' ) or ( endPath = 'webbbr01' and startPath = 'clemero02' );
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE paths(playerid, weight, path) AS ( SELECT edges.player2_id, edges.weight, ARRAY[edges.player1_id::text, edges.player2_id::text] FROM edges WHERE edges.player1_id = 'webbbr01' UNION ALL SELECT edges.player2_id, (paths.weight + edges.weight), paths.path || ARRAY[edges.player2_id::text] FROM paths JOIN edges ON paths.playerid = edges.player1_id AND  edges.player2_id != ALL(paths.path) ), edges AS (SELECT T.player1_id, T.player2_id, SUM(T.weight) as weight FROM (SELECT p1.playerid as player1_id, p2.playerid as player2_id, COUNT(*) as weight FROM Pitching as p1 JOIN Pitching as p2 ON p1.teamid = p2.teamid AND p1.yearid = p2.yearid AND p1.playerid != p2.playerid GROUP BY player1_id, player2_id UNION SELECT asf1.playerid as player1_id, asf2.playerid as player2_id, COUNT(*) as weight FROM AllstarFull as asf1 JOIN AllstarFull as asf2 ON asf1.teamid = asf2.teamid AND asf1.yearid = asf2.yearid AND asf1.playerid != asf2.playerid AND asf1.gp = 1 AND asf2.gp = 1 GROUP BY player1_id, player2_id) as T GROUP BY player1_id, player2_id) SELECT CASE WHEN EXISTS (SELECT * FROM paths WHERE paths.playerid = 'clemero02' AND paths.weight >= 3) THEN TRUE ELSE FALSE END as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE TEMPORARY TABLE nodes(p_id VARCHAR(255)); INSERT INTO nodes(p_id) SELECT pitching.playerID FROM pitching UNION SELECT allstarfull.playerID FROM allstarfull WHERE allstarfull.GP = 1; CREATE TEMPORARY TABLE edges(node1 VARCHAR(255),node2 VARCHAR(255),weight INT); INSERT INTO edges(node1,node2,weight) WITH data1(p_id,t,y) AS (SELECT nodes.p_id , appearances.teamID,appearances.yearID FROM appearances,nodes WHERE appearances.playerID=nodes.p_id), data2(p1_id,p2_id,t,y) AS (SELECT t1.p_id , t2.p_id , t1.t , t1.y FROM data1 AS t1 JOIN data1 AS t2 ON t1.p_id <> t2.p_id AND t1.y = t2.y AND t1.t = t2.t) SELECT p1_id , p2_id , COUNT(*) FROM data2  GROUP BY p1_id,p2_id ORDER BY COUNT(*) DESC ,p1_id,p2_id; WITH RECURSIVE path(start_node,end_node,path,length) AS ( SELECT node1, node2, node1||','||node2 || ',',weight FROM edges WHERE node1 = 'webbbr01' UNION SELECT e.node1,e.node2,p.path||e.node2|| ',',p.length+e.weight FROM path p  JOIN edges e ON e.node1 = p.end_node AND NOT e.node2 || ',' = ANY(string_to_array(p.path, ',')) ), paths(l) AS (SELECT length FROM path WHERE end_node = 'clemero02' AND length>=3 LIMIT 1) SELECT CASE WHEN l>= 3 THEN 't' ELSE 'f' END AS pathexists FROM paths; DROP TABLE nodes; DROP TABLE edges;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
drop view if exists g1_nodes; create temp view g1_nodes as ((select distinct playerid, yearid, teamid from allstarfull where gp = 1) union (select distinct playerid, yearid, teamid from pitching)); drop view if exists g1_edges; create temp view g1_edges as select p1,p2, count(*) as edge_wt from (select t1.playerid as p1,teamid,yearid,t2.playerid as p2 from g1_nodes t1 join g1_nodes t2 using(teamid,yearid) where t1.playerid!=t2.playerid) as m3 group by p1,p2 order by edge_wt desc; with recursive query_24 (path, p1, p2, plen) as ( select array[p1]::text[] as path, p1, p2, edge_wt as plen from g1_edges where p1 = 'webbbr01' union all select previ.path || g1_edges.p1::text, g1_edges.p1, g1_edges.p2,previ.plen + edge_wt from g1_edges, query_24 previ where g1_edges.p1 = previ.p2 and g1_edges.p1 != all(previ.path) ) select (case when count(*)>0 then true else false end) as pathexists from (select plen from query_24 where p2 = 'clemero02')as t2 where plen>=3;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
With Recursive nodeuni As( Select Distinct playerid, teamid, yearid From pitching Union Select Distinct playerid, teamid, yearid From allstarfull Where GP = 1 ), edges As( Select Distinct t1.playerid as n1, t2.playerid as n2, Count(Distinct t1.yearid) as wt From nodeuni t1 Join nodeuni t2 On (t1.teamid = t2.teamid and t1.yearid = t2.yearid and t1.playerid <> t2.playerid) Group By t1.playerid, t2.playerid ), walk As( Select n1, n2, wt From edges Where n1 = 'clemero02' Union Select walk.n1 as n1, edges.n2 as n2, Least(edges.wt + walk.wt,3) as wt From edges, walk Where walk.n2 = edges.n1 ) Select Count(*) > 0 as pathexists From Walk Where wt >= 3 and n2 = 'webbbr01';
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH HT AS( SELECT playerID AS playerID , (2*COALESCE(SUM(H2B),0)+3*COALESCE(SUM(H3B),0)+4*COALESCE(SUM(HR),0)) as runscore FROM Batting GROUP BY Batting.playerID ) SELECT HT.playerID AS playerid, People.namefirst AS firstname, HT.runscore as runscore FROM HT JOIN People ON People.playerID = HT.playerID GROUP BY HT.playerid, People.namefirst, HT.runscore ORDER BY runscore DESC, firstname ASC, playerid ASC limit 10;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH recursive temp1(playerid,teamid,yearid) as( SELECT distinct playerid,teamid,yearid,false FROM ( SELECT playerid,teamid,yearid FROM pitching UNION SELECT playerid,teamid,yearid FROM AllstarFull where GP=1 )as k ) , paths(node1,node2,weigh,isvalid,way,depth) as( SELECT distinct old1.playerid,old2.playerid,count( distinct old1.yearid),false,old1.playerid ||'<'|| old2.playerid,1 FROM temp1 old1 join temp1 old2 on(old1.teamid=old2.teamid and old1.yearid=old2.yearid) GROUP BY old1.playerID,old2.playerid ) , finalpath(node1,node2,weigh,isvalid,way,depth) as( SELECT node1,node2,weigh,isvalid,way,depth FROM paths where node1='webbbr01' UNION SELECT finalpath.node1 as node1,paths.node2 as node2,finalpath.weigh+paths.weigh as weigh,strpos(finalpath.way, paths.node2) > 0 ,finalpath.way ||'<'|| paths.node2,finalpath.depth+1 FROM finalpath,paths where finalpath.node2=paths.node1  and not (strpos(finalpath.way, paths.node2) > 0) and finalpath.depth<3 ) ,lmao(cost) as( SELECT coalesce(max(weigh),0) as dd FROM finalpath where finalpath.node1='webbbr01' and finalpath.node2='clemero02' group by node1,node2 ) SELECT case when cost>=3 then TRUE else FALSE end as pathexists FROM lmao;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
create or replace view graph1 as( with pgraph as( SELECT p1.playerid a, p2.playerid b, COUNT(*) edge FROM pitching p1, pitching p2 WHERE p1.playerid != p2.playerid AND p1.yearid = p2.yearid AND p1.teamid = p2.teamid GROUP BY p1.playerid, p2.playerid ),  agraph as( SELECT p1.playerid a, p2.playerid b, COUNT(*) edge FROM allstarfull p1, allstarfull p2 WHERE p1.playerid != p2.playerid AND p1.yearid = p2.yearid AND p1.teamid = p2.teamid AND p1.GP=1 AND p2.GP =1 GROUP BY p1.playerid, p2.playerid ) SELECT t.a p1, t.b p2 , SUM(edge) edge FROM (SELECT * FROM pgraph UNION ALL SELECT * FROM agraph) as t GROUP BY t.a,t.b ORDER BY edge DESC ); with recursive bfs( currEl  , visited , pathlength) as ( select p2 , array[ cast('webbbr01' as text) ]  , edge from graph1 where p1 = cast('webbbr01' as text) union all select p2 , bfs.visited|| cast(currEl as text ) , bfs.pathlength +edge from  graph1 join bfs on p1 = currEl and p2 != ALL(visited) ) select CASE when exists (Select pathlength from bfs where pathlength>=3 and currEl = cast('clemero02' as text) ) then true else false end as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE view g1 AS WITH Players AS (SELECT Pitching.playerid,Pitching.yearID,Pitching.teamID FROM Pitching UNION SELECT playerid,yearid,teamid FROM AllStarFull WHERE GP=1), Weights AS (SELECT p1.playerid as v1,p2.playerid as v2,COUNT(DISTINCT(p1.yearID)) AS weight FROM Players p1 JOIN Players p2 ON p1.playerID != p2.playerID AND p1.yearID = p2.yearID AND p1.teamID=p2.teamID GROUP BY p1.playerid,p2.playerid) SELECT * FROM Weights; WITH answer as( WITH RECURSIVE paths (src, dest, path, weight) AS ( SELECT Base.v1, Base.v2, ARRAY[Base.v1::text, Base.v2::text], Base.weight FROM g1 Base where Base.v1= 'webbbr01' UNION ALL SELECT paths.src, g1.v2, paths.path || ARRAY[g1.v2::text], paths.weight+g1.weight FROM paths JOIN g1 ON paths.dest = g1.v1 AND g1.v2::text != ALL(paths.path) ) select * from paths where paths.dest = 'clemero02') select case when max(weight) >= 3 then true else false end as pathexists from answer;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
WITH RECURSIVE graph0 AS ( (SELECT pc.playerid AS playerid, pc.teamid AS teamid, pc.yearID AS seasonid FROM pitching pc) UNION (SELECT asf.playerid AS playerid, asf.teamID AS teamid, asf.yearID AS seasonid FROM AllstarFull asf WHERE asf.GP = 1)), graph1 AS (SELECT g1.playerID::text AS player1, g2.playerID::text AS player2, COUNT(*) AS num_seasons FROM graph0 g1 JOIN graph0 g2 ON g1.playerID <> g2.playerID AND g1.teamID = g2.teamID AND g1.seasonid = g2.seasonid GROUP BY g1.playerID, g2.playerID), rec_query(player1, player2, path_len, cycleFound, path_nodes) AS (SELECT player1, player2, num_seasons, 'f'::boolean, ARRAY[player1, player2] FROM graph1 WHERE player1 = 'webbbr01' UNION ALL (SELECT rec_query.player1, graph1.player2, rec_query.path_len + graph1.num_seasons, graph1.player2 = ANY(path_nodes), (path_nodes || graph1.player2) FROM graph1, rec_query WHERE rec_query.player2 <> 'clemero02' AND graph1.player1 = rec_query.player2 AND cycleFound = 'f')) SELECT (CASE WHEN (SELECT EXISTS( SELECT * FROM rec_query WHERE rec_query.player1 = 'webbbr01' AND rec_query.player2 = 'clemero02' AND rec_query.path_len >= 3 AND rec_query.cycleFound = 'f' ) = 't') THEN 't' ELSE 'f' END) AS pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
CREATE VIEW t AS SELECT * FROM ( SELECT playerID, teamID, yearID FROM Pitching ) AS pitchers UNION ( SELECT playerID, teamID, yearID FROM AllstarFull WHERE GP = 1 ); CREATE VIEW nodes AS SELECT DISTINCT playerID FROM t; CREATE VIEW edges AS SELECT t1.playerID AS player_from, t2. playerID AS player_to, COUNT(t1.teamID) AS weight FROM t AS t1, t AS t2 WHERE t1.teamID = t2.teamID AND t1.yearID = t2.yearID AND t1.playerID != t2.playerID GROUP BY t1.playerID, t2.playerID HAVING COUNT(t1.teamID) > 0; WITH RECURSIVE search AS ( ( SELECT ARRAY[player_from, player_to] AS path, weight AS length, 1 AS nums FROM edges WHERE player_from = 'webbbr01' ) UNION ALL (SELECT CAST(array_append(path,player_to) AS varchar(10)[]) AS path, length+weight AS length, nums+1 AS nums FROM search, edges WHERE search.path[nums+1] = player_from AND player_to <> ALL(search.path) ) ), path_len AS ( SELECT path, length FROM search WHERE path[nums+1] = 'clemero02' AND length >= 3 LIMIT 1 ) SELECT CASE WHEN COUNT(*) > 0 THEN TRUE ELSE FALSE END AS pathexists FROM path_len;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
drop view if exists g12_nodes; CREATE VIEW g12_nodes AS SELECT DISTINCT playerid,teamid,yearid FROM pitching UNION SELECT playerid,teamid,yearid FROM allstarfull WHERE GP>0; drop view if exists g12_edges; CREATE VIEW g12_edges AS SELECT p1,p2,count(*)as wt FROM (SELECT t1.playerid as p1,teamid,yearid,t2.playerid as p2 FROM g12_nodes t1 JOIN g12_nodes t2 USING(teamid,yearid) WHERE t1.playerid!=t2.playerid) as t3 GROUP BY p1,p2 ORDER BY wt DESC; WITH RECURSIVE rec_q1 (p1, p2, l,path) as ( select p1, p2, wt as l,ARRAY[p1]::text[] as path from g12_edges where p1 = 'webbbr01' union all select g12_edges.p1, g12_edges.p2,prv.l +wt ,prv.path || g12_edges.p1::text from g12_edges, rec_q1 prv where g12_edges.p1 = prv.p2 and g12_edges.p1 != ALL(prv.path) ) SELECT CASE WHEN count(*)>0 THEN true ELSE false END AS pathexists FROM (select l from rec_q1 where p2 = 'clemero02')as t2 WHERE l>=3;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
create or replace view graph1_data as ( select playerid, teamid, yearid from pitching ) union ( select playerid, teamid, yearid from allstarfull where gp = 1 ) ; create or replace view G1 as ( select distinct n1, n2, sum(wt) as wt from ( select distinct d1.playerid as n1, d2.playerid as n2, d1.teamid as tid, d1.yearid as sid, 1::int as wt from graph1_data as d1, graph1_data as d2 where d1.yearid = d2.yearid AND d1.teamid = d2.teamid and d1.playerid <> d2.playerid ) as unwt group by n1, n2 order by n1 asc, n2 asc ) ; WITH RECURSIVE paths(src,dest,path_seq,path_length) AS ( SELECT e.n1, e.n2, ARRAY[e.n1, e.n2], e.wt FROM g1 e UNION ALL SELECT p.src, e.n2, (p.path_seq || ARRAY[e.n2])::varchar(10)[], p.path_length+e.wt FROM paths p JOIN g1 e ON p.dest = e.n1 AND e.n2 != ALL(p.path_seq) ) select CASE WHEN count(*) > 0 THEN 't'::bool ELSE 'f'::bool END as pathexists from (SELECT path_seq FROM paths WHERE src = 'webbbr01' and dest = 'clemero02' and path_length >=3 limit 1) as ans ;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive t1 as ( select p1.playerid as player1_id, p2.playerid as player2_id, count(p1.playerid) as wt from pitching as p1, pitching as p2 where p1.teamid = p2.teamid and p1.yearid = p2.yearid and p1.playerid != p2.playerid group by p1.playerid, p2.playerid ), t2 as ( select p1.playerid as player1_id, p2.playerid as player2_id, count(p1.playerid) as wt from allstarfull as p1, allstarfull as p2 where p1.teamid = p2.teamid and p1.yearid = p2.yearid and p1.playerid != p2.playerid and p1.gp = 1 and p2.gp = 1 group by p1.playerid, p2.playerid ), t3 as ( select * from t1 union select * from t2 ), t4 as ( select player1_id, player2_id, sum(wt) as wt from t3 group by player1_id, player2_id ), t5 (dst_playerid, path, len) as ( select t4.player2_id, ARRAY[t4.player1_id::text, t4.player2_id::text] as path, t4.wt as len from t4 where t4.player1_id = 'webbbr01' union all select f.player2_id, (g.path || ARRAY[f.player2_id::text]), g.len + f.wt from t3 as f join t5 as g on f.player1_id = g.dst_playerid and f.player2_id != ALL(g.path) ) select case when exists (select * from t5 where dst_playerid = 'clemero02' and len >=3) then TRUE else FALSE end as pathexists;
create or replace view graph1 as select p1, p2, count(*) as w from (select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from pitching as table1, (select * from allstarfull where GP = 1) as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid union select table1.playerid as p1, table2.playerid as p2, table1.teamid, table1.yearid from (select * from allstarfull where GP = 1) as table1, pitching as table2 where table1.teamid = table2.teamid and table1.yearid = table2.yearid and not table1.playerid = table2.playerid) as temp group by p1, p2; with recursive sub as (select array[p1::text, p2::text] as path, p2, w as dist from graph1 where p1 = 'webbbr01' union all select recur.path || graph1.p2::text, graph1.p2, (dist + w) as dist from sub as recur, graph1 where graph1.p1 = recur.p2 and not graph1.p2 = any (recur.path) and not recur.p2 = 'clemero02') select case when count(*) > 0 then True else False end as pathexists from sub where dist >= 3 and p2 = 'clemero02';
with recursive pitchingPlayers as ( select distinct playerid, yearid, teamid from Pitching ), allStarPlayers as ( select distinct playerid, yearid, teamid from AllstarFull where GP=1 ), relevantPlayers as ( select * from pitchingPlayers union select * from allStarPlayers ), routeTemp as ( select p1.playerid as playera, p2.playerid as playerb, 1 as edge from relevantPlayers as p1, relevantPlayers as p2 where p1.yearid = p2.yearid and p2.teamid = p1.teamid ), routes(playera, playerb, edge, path) as ( select playera, playerb, edge, array[playera::text, playerb::text] from routeTemp where playera = 'webbbr01' union all select distinct r1.playera, r2.playerb, 0, path || r2.playerb::text from routes as r1, routeTemp as r2 where r1.playerb = r2.playera and (not (r2.playerb = any(path))) ) select exists (select playera, playerb from routes where playerb = 'clemero02') as pathexists;
